#jinja2: lstrip_blocks: True, trim_blocks: True
---
# =========================================================================
# LIONS INFRASTRUCTURE 5.0 - POSTGRESQL STATEFULSET
# =========================================================================
# Description: StatefulSet PostgreSQL avec haute disponibilité et sécurité renforcée
# Version: 5.0.0
# Maintainer: DevOps Team
# Documentation: https://docs.lions.dev/database/postgresql
# =========================================================================

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: {{ postgres_service_name | default(app_name) }}
  namespace: {{ postgres_namespace | default(app_namespace) }}
  labels:
    # Labels standards
    app: {{ postgres_service_name | default(app_name) }}
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: {{ postgres_service_name | default(app_name) }}
    app.kubernetes.io/version: "{{ postgres_version }}"
    app.kubernetes.io/component: database
    app.kubernetes.io/part-of: lions-infrastructure
    app.kubernetes.io/managed-by: ansible

    # Labels environnement
    environment: "{{ app_environment }}"
    lions.dev/environment: "{{ app_environment }}"
    lions.dev/tier: database
    lions.dev/backup-enabled: "{{ postgres_backup_enabled | string }}"
    lions.dev/monitoring-enabled: "{{ postgres_monitoring_enabled | string }}"

    # Labels opérationnels
    version: "{{ lions_config_version | default('5.0.0') }}"
    deployment-date: "{{ ansible_date_time.iso8601 }}"

  annotations:
    # Annotations de configuration
    lions.dev/config-checksum: "{{ postgres_config_checksum | default('') }}"
    lions.dev/secret-checksum: "{{ postgres_secret_checksum | default('') }}"

    # Annotations de déploiement
    deployment.kubernetes.io/revision: "{{ postgres_deployment_revision | default('1') }}"
    kubectl.kubernetes.io/last-applied-configuration: |
      Generated by Ansible on {{ ansible_date_time.iso8601 }}

    # Annotations de sécurité
    seccomp.security.alpha.kubernetes.io/pod: runtime/default

    # Annotations de monitoring
    prometheus.io/scrape: "{{ postgres_monitoring_enabled | string }}"
    prometheus.io/port: "{{ postgres_exporter_port | default(9187) }}"
    prometheus.io/path: "/metrics"

spec:
  serviceName: {{ postgres_service_name | default(app_name) }}-headless
  podManagementPolicy: {{ postgres_pod_management_policy | default('OrderedReady') }}

  # Configuration des répliques selon l'environnement
  replicas: {{ postgres_replicas[app_environment] | default(postgres_replicas.default | default(1)) }}

  # Stratégie de mise à jour
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      partition: {{ postgres_update_partition | default(0) }}

  # Configuration du StatefulSet
  revisionHistoryLimit: {{ postgres_revision_history_limit | default(3) }}

  selector:
    matchLabels:
      app: {{ postgres_service_name | default(app_name) }}
      app.kubernetes.io/name: postgresql
      app.kubernetes.io/instance: {{ postgres_service_name | default(app_name) }}

  template:
    metadata:
      labels:
        # Labels du pod (identiques au StatefulSet)
        app: {{ postgres_service_name | default(app_name) }}
        app.kubernetes.io/name: postgresql
        app.kubernetes.io/instance: {{ postgres_service_name | default(app_name) }}
        app.kubernetes.io/version: "{{ postgres_version }}"
        app.kubernetes.io/component: database
        app.kubernetes.io/part-of: lions-infrastructure

        environment: "{{ app_environment }}"
        lions.dev/environment: "{{ app_environment }}"
        lions.dev/tier: database

        # Labels spécifiques au pod
        lions.dev/pod-template-hash: "{{ postgres_pod_template_hash | default('') }}"

      annotations:
        # Annotations de monitoring
        prometheus.io/scrape: "{{ postgres_monitoring_enabled | string }}"
        prometheus.io/port: "{{ postgres_exporter_port | default(9187) }}"
        prometheus.io/path: "/metrics"

        # Annotations de sécurité
        seccomp.security.alpha.kubernetes.io/pod: runtime/default
        container.apparmor.security.beta.kubernetes.io/postgresql: runtime/default
        container.apparmor.security.beta.kubernetes.io/postgres-exporter: runtime/default

        # Annotations de configuration
        checksum/config: "{{ postgres_config_checksum | default('') }}"
        checksum/secret: "{{ postgres_secret_checksum | default('') }}"

        # Annotations de backup
        {% if postgres_backup_enabled | default(true) %}
        backup.lions.dev/enabled: "true"
        backup.lions.dev/schedule: "{{ postgres_backup_schedule | default('0 2 * * *') }}"
        backup.lions.dev/retention: "{{ postgres_backup_retention | default('30d') }}"
        {% endif %}

        # Annotations personnalisées
        {% for key, value in postgres_pod_annotations.items() | default([]) %}
        {{ key }}: "{{ value }}"
        {% endfor %}

    spec:
      # Configuration du service account
      serviceAccountName: {{ postgres_service_name | default(app_name) }}
      automountServiceAccountToken: {{ postgres_automount_service_account_token | default(false) }}

      # Configuration de sécurité du pod
      securityContext:
        # Utilisateur non-root
        runAsNonRoot: true
        runAsUser: {{ postgres_security_context.run_as_user | default(999) }}  # postgres user
        runAsGroup: {{ postgres_security_context.run_as_group | default(999) }}  # postgres group
        fsGroup: {{ postgres_security_context.fs_group | default(999) }}
        fsGroupChangePolicy: {{ postgres_security_context.fs_group_change_policy | default('OnRootMismatch') }}

        # Contrôles de sécurité avancés
        seccompProfile:
          type: {{ postgres_security_context.seccomp_profile | default('RuntimeDefault') }}
        supplementalGroups: {{ postgres_security_context.supplemental_groups | default([]) | to_json }}

        # Contrôles syscall
        sysctls: {{ postgres_security_context.sysctls | default([]) | to_json }}

      # Configuration DNS
      dnsPolicy: {{ postgres_dns_policy | default('ClusterFirst') }}
      dnsConfig:
        options:
          - name: ndots
            value: "{{ postgres_dns_ndots | default('2') }}"
          - name: timeout
            value: "{{ postgres_dns_timeout | default('5') }}"
        {% if postgres_dns_searches | default([]) %}
        searches: {{ postgres_dns_searches | to_json }}
        {% endif %}
        {% if postgres_dns_nameservers | default([]) %}
        nameservers: {{ postgres_dns_nameservers | to_json }}
        {% endif %}

      # Configuration des affinités pour la haute disponibilité
      {% if postgres_ha_enabled | default(false) and postgres_replicas[app_environment] | default(1) > 1 %}
      affinity:
        podAntiAffinity:
          # Anti-affinité préférée pour éviter les pods sur le même nœud
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchExpressions:
                    - key: app.kubernetes.io/name
                      operator: In
                      values: [postgresql]
                    - key: app.kubernetes.io/instance
                      operator: In
                      values: ["{{ postgres_service_name | default(app_name) }}"]
                topologyKey: kubernetes.io/hostname

            # Anti-affinité sur les zones de disponibilité
            - weight: 50
              podAffinityTerm:
                labelSelector:
                  matchExpressions:
                    - key: app.kubernetes.io/name
                      operator: In
                      values: [postgresql]
                topologyKey: topology.kubernetes.io/zone

        # Affinité pour les nœuds avec SSD si disponible
        {% if postgres_node_affinity_enabled | default(true) %}
        nodeAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 80
              preference:
                matchExpressions:
                  - key: lions.dev/storage-type
                    operator: In
                    values: [ssd, nvme]
            - weight: 60
              preference:
                matchExpressions:
                  - key: lions.dev/node-role
                    operator: In
                    values: [database]
        {% endif %}
      {% endif %}

      # Tolérations pour les nœuds dédiés
      {% if postgres_tolerations | default([]) %}
      tolerations:
        {% for toleration in postgres_tolerations %}
        - key: "{{ toleration.key }}"
          operator: "{{ toleration.operator | default('Equal') }}"
          value: "{{ toleration.value | default('') }}"
          effect: "{{ toleration.effect }}"
          {% if toleration.tolerationSeconds is defined %}
          tolerationSeconds: {{ toleration.tolerationSeconds }}
          {% endif %}
        {% endfor %}
      {% endif %}

      # Sélecteur de nœuds
      {% if postgres_node_selector | default({}) %}
      nodeSelector:
        {% for key, value in postgres_node_selector.items() %}
        {{ key }}: "{{ value }}"
        {% endfor %}
      {% endif %}

      # Configuration de la priorité
      {% if postgres_priority_class_name %}
      priorityClassName: {{ postgres_priority_class_name }}
      {% endif %}

      # Configuration du hostname
      hostname: {{ postgres_hostname_prefix | default('postgresql') }}-$(HOSTNAME)
      subdomain: {{ postgres_service_name | default(app_name) }}-headless

      # Stratégie de redémarrage
      restartPolicy: Always

      # Configuration des volumes d'initialisation
      {% if postgres_init_containers_enabled | default(true) %}
      initContainers:
        # Container d'initialisation pour les permissions
        - name: postgres-init-permissions
          image: "{{ postgres_init_image | default('busybox:1.35') }}"
          imagePullPolicy: IfNotPresent

          securityContext:
            runAsNonRoot: false
            runAsUser: 0
            capabilities:
              add: [CHOWN, FOWNER]
              drop: [ALL]

          command:
            - /bin/sh
            - -c
            - |
              set -e
              echo "🔧 Initialisation des permissions PostgreSQL..."

              # Création et configuration des répertoires
              mkdir -p /var/lib/postgresql/data/pgdata
              mkdir -p /var/lib/postgresql/backup
              mkdir -p /var/lib/postgresql/archive

              # Attribution des permissions correctes
              chown -R 999:999 /var/lib/postgresql/data
              chown -R 999:999 /var/lib/postgresql/backup
              chown -R 999:999 /var/lib/postgresql/archive

              chmod 700 /var/lib/postgresql/data/pgdata
              chmod 755 /var/lib/postgresql/backup
              chmod 755 /var/lib/postgresql/archive

              echo "✅ Permissions configurées avec succès"

          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
            {% if postgres_backup_enabled | default(true) %}
            - name: postgres-backup
              mountPath: /var/lib/postgresql/backup
            {% endif %}

          resources:
            requests:
              cpu: "50m"
              memory: "64Mi"
            limits:
              cpu: "100m"
              memory: "128Mi"

        {% if postgres_custom_init_enabled | default(false) %}
        # Container d'initialisation personnalisé
        - name: postgres-custom-init
          image: "{{ postgres_custom_init_image | default('postgres:' + postgres_version) }}"
          imagePullPolicy: IfNotPresent

          securityContext:
            runAsNonRoot: true
            runAsUser: 999
            runAsGroup: 999
            capabilities:
              drop: [ALL]
            readOnlyRootFilesystem: true

          command:
            - /bin/bash
            - -c
            - |
              set -e
              echo "🚀 Initialisation personnalisée PostgreSQL..."

              # Scripts d'initialisation personnalisés
              if [ -d "/docker-entrypoint-initdb.d" ]; then
                  for f in /docker-entrypoint-initdb.d/*; do
                      case "$f" in
                          *.sh)     echo "Exécution de $f"; . "$f" ;;
                          *.sql)    echo "Exécution de $f"; psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" < "$f" ;;
                          *.sql.gz) echo "Exécution de $f"; gunzip -c "$f" | psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" ;;
                          *)        echo "Ignorer $f" ;;
                      esac
                  done
              fi

              echo "✅ Initialisation personnalisée terminée"

          env:
            - name: POSTGRES_USER
              value: "{{ postgres_admin_user | default('postgres') }}"
            - name: POSTGRES_DB
              value: "{{ postgres_default_database | default('postgres') }}"
            - name: PGDATA
              value: /var/lib/postgresql/data/pgdata

          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
            - name: postgres-init-scripts
              mountPath: /docker-entrypoint-initdb.d
              readOnly: true
            - name: tmp
              mountPath: /tmp

          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "200m"
              memory: "256Mi"
        {% endif %}
      {% endif %}

      containers:
        # =====================================================================
        # CONTAINER PRINCIPAL POSTGRESQL
        # =====================================================================
        - name: postgresql
          image: "{{ postgres_image_registry | default('') }}{% if postgres_image_registry %}{{ postgres_image_registry }}/{% endif %}postgres:{{ postgres_version }}"
          imagePullPolicy: {{ postgres_image_pull_policy | default('IfNotPresent') }}

          # Configuration de sécurité du container
          securityContext:
            # Utilisateur non-root
            runAsNonRoot: true
            runAsUser: 999  # postgres user
            runAsGroup: 999  # postgres group

            # Contrôles de sécurité avancés
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: {{ postgres_read_only_root_filesystem | default(true) }}

            # Capacités minimales
            capabilities:
              drop: [ALL]
              {% if postgres_security_capabilities | default([]) %}
              add: {{ postgres_security_capabilities | to_json }}
              {% endif %}

            # Profil seccomp
            seccompProfile:
              type: RuntimeDefault

          # Configuration des ports
          ports:
            - name: postgresql
              containerPort: {{ postgres_port | default(5432) }}
              protocol: TCP
            {% if postgres_monitoring_enabled | default(true) %}
            - name: metrics
              containerPort: {{ postgres_exporter_port | default(9187) }}
              protocol: TCP
            {% endif %}

          # Variables d'environnement
          env:
            # Configuration de base
            - name: POSTGRES_USER
              value: "{{ postgres_admin_user | default('postgres') }}"

            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ postgres_admin_password_secret | default(postgres_service_name + '-admin-secret') }}
                  key: {{ postgres_admin_password_secret_key | default('password') }}

            - name: POSTGRES_DB
              value: "{{ postgres_default_database | default('postgres') }}"

            - name: PGDATA
              value: /var/lib/postgresql/data/pgdata

            # Configuration avancée
            - name: POSTGRES_INITDB_ARGS
              value: "{{ postgres_initdb_args | default('--encoding=UTF8 --locale=C') }}"

            - name: POSTGRES_INITDB_WALDIR
              value: "{{ postgres_initdb_waldir | default('/var/lib/postgresql/data/pg_wal') }}"

            # Configuration du logging
            - name: POSTGRES_LOGGING_COLLECTOR
              value: "{{ postgres_logging_collector | default('on') }}"

            # Configuration des connexions
            - name: POSTGRES_MAX_CONNECTIONS
              value: "{{ postgres_max_connections[app_environment] | default(postgres_max_connections.default | default(100)) }}"

            # Configuration mémoire
            - name: POSTGRES_SHARED_BUFFERS
              value: "{{ postgres_shared_buffers[app_environment] | default(postgres_shared_buffers.default | default('256MB')) }}"

            - name: POSTGRES_EFFECTIVE_CACHE_SIZE
              value: "{{ postgres_effective_cache_size[app_environment] | default(postgres_effective_cache_size.default | default('1GB')) }}"

            {% if postgres_ha_enabled | default(false) %}
            # Configuration haute disponibilité
            - name: POSTGRES_REPLICATION_MODE
              value: "{{ postgres_replication_mode | default('async') }}"

            - name: POSTGRES_REPLICATION_USER
              value: "{{ postgres_replication_user | default('replicator') }}"

            - name: POSTGRES_REPLICATION_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ postgres_replication_password_secret | default(postgres_service_name + '-replication-secret') }}
                  key: {{ postgres_replication_password_secret_key | default('password') }}

            - name: POSTGRES_MASTER_SERVICE
              value: "{{ postgres_service_name | default(app_name) }}-primary"

            - name: POSTGRES_REPLICA_SERVICE
              value: "{{ postgres_service_name | default(app_name) }}-replica"
            {% endif %}

            # Variables d'environnement personnalisées
            {% for env_var in postgres_custom_env_vars | default([]) %}
            - name: "{{ env_var.name }}"
              {% if env_var.value is defined %}
              value: "{{ env_var.value }}"
              {% elif env_var.valueFrom is defined %}
              valueFrom: {{ env_var.valueFrom | to_json }}
              {% endif %}
            {% endfor %}

          # Configuration des volumes
          volumeMounts:
            # Volume principal des données
            - name: postgres-data
              mountPath: /var/lib/postgresql/data

            # Configuration PostgreSQL
            - name: postgres-config
              mountPath: /etc/postgresql/postgresql.conf
              subPath: postgresql.conf
              readOnly: true

            - name: postgres-config
              mountPath: /etc/postgresql/pg_hba.conf
              subPath: pg_hba.conf
              readOnly: true

            {% if postgres_custom_config_enabled | default(false) %}
            - name: postgres-config
              mountPath: /etc/postgresql/conf.d
              readOnly: true
            {% endif %}

            # Volumes temporaires (filesystem read-only)
            {% if postgres_read_only_root_filesystem | default(true) %}
            - name: tmp
              mountPath: /tmp

            - name: var-run
              mountPath: /var/run/postgresql

            - name: var-lock
              mountPath: /var/lock
            {% endif %}

            # Volume de backup
            {% if postgres_backup_enabled | default(true) %}
            - name: postgres-backup
              mountPath: /var/lib/postgresql/backup
            {% endif %}

            # Scripts personnalisés
            {% if postgres_custom_scripts_enabled | default(false) %}
            - name: postgres-scripts
              mountPath: /usr/local/bin/custom-scripts
              readOnly: true
            {% endif %}

          # Configuration des ressources
          resources:
            requests:
              cpu: "{{ postgres_resources[app_environment].requests.cpu | default('200m') }}"
              memory: "{{ postgres_resources[app_environment].requests.memory | default('256Mi') }}"
              {% if postgres_resources[app_environment].requests.storage is defined %}
              ephemeral-storage: "{{ postgres_resources[app_environment].requests.storage }}"
              {% endif %}
            limits:
              cpu: "{{ postgres_resources[app_environment].limits.cpu | default('1000m') }}"
              memory: "{{ postgres_resources[app_environment].limits.memory | default('1Gi') }}"
              {% if postgres_resources[app_environment].limits.storage is defined %}
              ephemeral-storage: "{{ postgres_resources[app_environment].limits.storage }}"
              {% endif %}

          # Sondes de santé avancées
          startupProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - |
                  pg_isready -U {{ postgres_admin_user | default('postgres') }} -h 127.0.0.1 -p {{ postgres_port | default(5432) }} -q
            initialDelaySeconds: {{ postgres_startup_probe.initial_delay_seconds | default(10) }}
            periodSeconds: {{ postgres_startup_probe.period_seconds | default(5) }}
            timeoutSeconds: {{ postgres_startup_probe.timeout_seconds | default(3) }}
            failureThreshold: {{ postgres_startup_probe.failure_threshold | default(30) }}
            successThreshold: {{ postgres_startup_probe.success_threshold | default(1) }}

          readinessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - |
                  pg_isready -U {{ postgres_admin_user | default('postgres') }} -h 127.0.0.1 -p {{ postgres_port | default(5432) }} -q && \
                  psql -U {{ postgres_admin_user | default('postgres') }} -h 127.0.0.1 -p {{ postgres_port | default(5432) }} -d {{ postgres_default_database | default('postgres') }} -c "SELECT 1" > /dev/null
            initialDelaySeconds: {{ postgres_readiness_probe.initial_delay_seconds | default(5) }}
            periodSeconds: {{ postgres_readiness_probe.period_seconds | default(10) }}
            timeoutSeconds: {{ postgres_readiness_probe.timeout_seconds | default(5) }}
            failureThreshold: {{ postgres_readiness_probe.failure_threshold | default(3) }}
            successThreshold: {{ postgres_readiness_probe.success_threshold | default(1) }}

          livenessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - |
                  pg_isready -U {{ postgres_admin_user | default('postgres') }} -h 127.0.0.1 -p {{ postgres_port | default(5432) }} -q
            initialDelaySeconds: {{ postgres_liveness_probe.initial_delay_seconds | default(30) }}
            periodSeconds: {{ postgres_liveness_probe.period_seconds | default(30) }}
            timeoutSeconds: {{ postgres_liveness_probe.timeout_seconds | default(10) }}
            failureThreshold: {{ postgres_liveness_probe.failure_threshold | default(3) }}
            successThreshold: {{ postgres_liveness_probe.success_threshold | default(1) }}

          # Configuration du cycle de vie
          lifecycle:
            preStop:
              exec:
                command:
                  - /bin/sh
                  - -c
                  - |
                    echo "🛑 Arrêt gracieux de PostgreSQL..."

                    # Signal d'arrêt propre à PostgreSQL
                    pg_ctl stop -D /var/lib/postgresql/data/pgdata -m fast -w -t {{ postgres_shutdown_timeout | default(60) }}

                    {% if postgres_backup_on_shutdown | default(false) %}
                    # Backup avant arrêt si configuré
                    echo "💾 Sauvegarde avant arrêt..."
                    pg_dump -U {{ postgres_admin_user | default('postgres') }} -h 127.0.0.1 -p {{ postgres_port | default(5432) }} {{ postgres_default_database | default('postgres') }} > /var/lib/postgresql/backup/shutdown-backup-$(date +%Y%m%d_%H%M%S).sql
                    {% endif %}

                    echo "✅ Arrêt gracieux terminé"

          # Configuration terminaison
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: FallbackToLogsOnError

        {% if postgres_monitoring_enabled | default(true) %}
        # =====================================================================
        # CONTAINER POSTGRES EXPORTER
        # =====================================================================
        - name: postgres-exporter
          image: "{{ postgres_exporter_image | default('prometheuscommunity/postgres-exporter:v0.14.0') }}"
          imagePullPolicy: {{ postgres_exporter_image_pull_policy | default('IfNotPresent') }}

          # Configuration de sécurité
          securityContext:
            runAsNonRoot: true
            runAsUser: {{ postgres_exporter_user_id | default(65534) }}  # nobody user
            runAsGroup: {{ postgres_exporter_group_id | default(65534) }}  # nobody group
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop: [ALL]
            seccompProfile:
              type: RuntimeDefault

          ports:
            - name: metrics
              containerPort: {{ postgres_exporter_port | default(9187) }}
              protocol: TCP

          env:
            # Configuration de connexion
            - name: DATA_SOURCE_NAME
              value: "postgresql://{{ postgres_monitoring_user | default(postgres_admin_user | default('postgres')) }}:$(POSTGRES_PASSWORD)@127.0.0.1:{{ postgres_port | default(5432) }}/{{ postgres_default_database | default('postgres') }}?sslmode={{ postgres_ssl_mode | default('disable') }}"

            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ postgres_monitoring_password_secret | default(postgres_admin_password_secret | default(postgres_service_name + '-admin-secret')) }}
                  key: {{ postgres_monitoring_password_secret_key | default('password') }}

            # Configuration de l'exporter
            - name: PG_EXPORTER_WEB_LISTEN_ADDRESS
              value: "0.0.0.0:{{ postgres_exporter_port | default(9187) }}"

            - name: PG_EXPORTER_WEB_TELEMETRY_PATH
              value: "{{ postgres_exporter_telemetry_path | default('/metrics') }}"

            - name: PG_EXPORTER_DISABLE_DEFAULT_METRICS
              value: "{{ postgres_exporter_disable_default_metrics | default('false') }}"

            - name: PG_EXPORTER_DISABLE_SETTINGS_METRICS
              value: "{{ postgres_exporter_disable_settings_metrics | default('false') }}"

            - name: PG_EXPORTER_AUTO_DISCOVER_DATABASES
              value: "{{ postgres_exporter_auto_discover_databases | default('true') }}"

            # Configuration du logging
            - name: PG_EXPORTER_LOG_LEVEL
              value: "{{ postgres_exporter_log_level | default('info') }}"

          # Configuration des volumes (minimum requis)
          volumeMounts:
            {% if postgres_read_only_root_filesystem | default(true) %}
            - name: tmp
              mountPath: /tmp
            {% endif %}

          # Configuration des ressources
          resources:
            requests:
              cpu: "{{ postgres_exporter_resources.requests.cpu | default('50m') }}"
              memory: "{{ postgres_exporter_resources.requests.memory | default('64Mi') }}"
            limits:
              cpu: "{{ postgres_exporter_resources.limits.cpu | default('200m') }}"
              memory: "{{ postgres_exporter_resources.limits.memory | default('256Mi') }}"

          # Sondes de santé pour l'exporter
          readinessProbe:
            httpGet:
              path: {{ postgres_exporter_telemetry_path | default('/metrics') }}
              port: {{ postgres_exporter_port | default(9187) }}
              scheme: HTTP
            initialDelaySeconds: {{ postgres_exporter_readiness_probe.initial_delay_seconds | default(5) }}
            periodSeconds: {{ postgres_exporter_readiness_probe.period_seconds | default(10) }}
            timeoutSeconds: {{ postgres_exporter_readiness_probe.timeout_seconds | default(3) }}
            failureThreshold: {{ postgres_exporter_readiness_probe.failure_threshold | default(3) }}

          livenessProbe:
            httpGet:
              path: {{ postgres_exporter_telemetry_path | default('/metrics') }}
              port: {{ postgres_exporter_port | default(9187) }}
              scheme: HTTP
            initialDelaySeconds: {{ postgres_exporter_liveness_probe.initial_delay_seconds | default(15) }}
            periodSeconds: {{ postgres_exporter_liveness_probe.period_seconds | default(20) }}
            timeoutSeconds: {{ postgres_exporter_liveness_probe.timeout_seconds | default(3) }}
            failureThreshold: {{ postgres_exporter_liveness_probe.failure_threshold | default(3) }}

          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: FallbackToLogsOnError
        {% endif %}

        {% if postgres_backup_sidecar_enabled | default(false) %}
        # =====================================================================
        # CONTAINER BACKUP SIDECAR
        # =====================================================================
        - name: postgres-backup-sidecar
          image: "{{ postgres_backup_image | default('postgres:' + postgres_version) }}"
          imagePullPolicy: {{ postgres_backup_image_pull_policy | default('IfNotPresent') }}

          securityContext:
            runAsNonRoot: true
            runAsUser: 999
            runAsGroup: 999
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop: [ALL]
            seccompProfile:
              type: RuntimeDefault

          command:
            - /bin/bash
            - -c
            - |
              set -e
              echo "🔄 Démarrage du service de backup PostgreSQL..."

              while true; do
                  # Attendre le prochain cycle de backup
                  sleep {{ postgres_backup_interval | default(3600) }}  # 1 heure par défaut

                  echo "💾 Début du backup PostgreSQL..."
                  BACKUP_FILE="/var/lib/postgresql/backup/backup-$(date +%Y%m%d_%H%M%S).sql"

                  # Exécution du backup
                  if pg_dump -U {{ postgres_admin_user | default('postgres') }} -h 127.0.0.1 -p {{ postgres_port | default(5432) }} {{ postgres_default_database | default('postgres') }} > "$BACKUP_FILE"; then
                      echo "✅ Backup réussi: $BACKUP_FILE"

                      # Compression du backup
                      gzip "$BACKUP_FILE"
                      echo "📦 Backup compressé: $BACKUP_FILE.gz"

                      # Nettoyage des anciens backups
                      find /var/lib/postgresql/backup -name "backup-*.sql.gz" -mtime +{{ postgres_backup_retention_days | default(7) }} -delete
                      echo "🧹 Anciens backups nettoyés"
                  else
                      echo "❌ Échec du backup PostgreSQL"
                  fi
              done

          env:
            - name: PGPASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ postgres_admin_password_secret | default(postgres_service_name + '-admin-secret') }}
                  key: {{ postgres_admin_password_secret_key | default('password') }}

          volumeMounts:
            - name: postgres-backup
              mountPath: /var/lib/postgresql/backup
            - name: tmp
              mountPath: /tmp

          resources:
            requests:
              cpu: "{{ postgres_backup_resources.requests.cpu | default('50m') }}"
              memory: "{{ postgres_backup_resources.requests.memory | default('128Mi') }}"
            limits:
              cpu: "{{ postgres_backup_resources.limits.cpu | default('500m') }}"
              memory: "{{ postgres_backup_resources.limits.memory | default('512Mi') }}"
        {% endif %}

      # =====================================================================
      # CONFIGURATION DES VOLUMES
      # =====================================================================
      volumes:
        # Configuration PostgreSQL
        - name: postgres-config
          configMap:
            name: {{ postgres_service_name | default(app_name) }}-config
            defaultMode: 0444

        # Volumes temporaires pour filesystem read-only
        {% if postgres_read_only_root_filesystem | default(true) %}
        - name: tmp
          emptyDir:
            sizeLimit: {{ postgres_tmp_volume_size | default('1Gi') }}

        - name: var-run
          emptyDir:
            sizeLimit: {{ postgres_var_run_volume_size | default('100Mi') }}

        - name: var-lock
          emptyDir:
            sizeLimit: {{ postgres_var_lock_volume_size | default('100Mi') }}
        {% endif %}

        # Scripts d'initialisation personnalisés
        {% if postgres_custom_init_enabled | default(false) %}
        - name: postgres-init-scripts
          configMap:
            name: {{ postgres_service_name | default(app_name) }}-init-scripts
            defaultMode: 0555
        {% endif %}

        # Scripts personnalisés
        {% if postgres_custom_scripts_enabled | default(false) %}
        - name: postgres-scripts
          configMap:
            name: {{ postgres_service_name | default(app_name) }}-scripts
            defaultMode: 0555
        {% endif %}

        # Volume de backup (si pas persistant)
        {% if postgres_backup_enabled | default(true) and not postgres_backup_persistent_storage | default(true) %}
        - name: postgres-backup
          emptyDir:
            sizeLimit: {{ postgres_backup_volume_size | default('10Gi') }}
        {% endif %}

        # Volumes ephémères pour les données si pas de stockage persistant
        {% if not postgres_persistent_storage | default(true) %}
        - name: postgres-data
          emptyDir:
            sizeLimit: {{ postgres_data_volume_size | default('10Gi') }}
        {% endif %}

      # Configuration finale du pod
      terminationGracePeriodSeconds: {{ postgres_termination_grace_period | default(120) }}

      # Configuration des images pull secrets
      {% if postgres_image_pull_secrets | default([]) %}
      imagePullSecrets:
        {% for secret in postgres_image_pull_secrets %}
        - name: {{ secret }}
        {% endfor %}
      {% endif %}

  # =====================================================================
  # VOLUME CLAIM TEMPLATES (STOCKAGE PERSISTANT)
  # =====================================================================
  {% if postgres_persistent_storage | default(true) %}
  volumeClaimTemplates:
    # Volume principal des données
    - metadata:
        name: postgres-data
        labels:
          app: {{ postgres_service_name | default(app_name) }}
          app.kubernetes.io/name: postgresql
          app.kubernetes.io/instance: {{ postgres_service_name | default(app_name) }}
          lions.dev/volume-type: data
        annotations:
          volume.beta.kubernetes.io/storage-class: "{{ postgres_storage_class | default('standard') }}"
          {% if postgres_volume_annotations | default({}) %}
          {% for key, value in postgres_volume_annotations.items() %}
          {{ key }}: "{{ value }}"
          {% endfor %}
          {% endif %}
      spec:
        accessModes:
          - {{ postgres_access_mode | default('ReadWriteOnce') }}
        storageClassName: {{ postgres_storage_class | default('standard') }}
        resources:
          requests:
            storage: {{ postgres_storage_sizes[app_environment] | default(postgres_storage_sizes.default | default('20Gi')) }}
        {% if postgres_volume_selector | default({}) %}
        selector:
          matchLabels:
            {% for key, value in postgres_volume_selector.items() %}
            {{ key }}: "{{ value }}"
            {% endfor %}
        {% endif %}

    # Volume de backup persistant
    {% if postgres_backup_enabled | default(true) and postgres_backup_persistent_storage | default(true) %}
    - metadata:
        name: postgres-backup
        labels:
          app: {{ postgres_service_name | default(app_name) }}
          app.kubernetes.io/name: postgresql
          app.kubernetes.io/instance: {{ postgres_service_name | default(app_name) }}
          lions.dev/volume-type: backup
        annotations:
          volume.beta.kubernetes.io/storage-class: "{{ postgres_backup_storage_class | default(postgres_storage_class | default('standard')) }}"
      spec:
        accessModes:
          - {{ postgres_backup_access_mode | default('ReadWriteOnce') }}
        storageClassName: {{ postgres_backup_storage_class | default(postgres_storage_class | default('standard')) }}
        resources:
          requests:
            storage: {{ postgres_backup_storage_sizes[app_environment] | default(postgres_backup_storage_sizes.default | default('50Gi')) }}
    {% endif %}
  {% endif %}

---
# =========================================================================
# DOCUMENTATION ET EXEMPLES
# =========================================================================
# 
# Ce StatefulSet PostgreSQL 5.0 offre les fonctionnalités suivantes:
# 
# 🔒 SÉCURITÉ RENFORCÉE:
#   - Containers non-root avec seccomp et AppArmor
#   - Filesystem read-only avec volumes temporaires
#   - Gestion sécurisée des secrets via Kubernetes Secrets
#   - Politique de sécurité des pods restrictive
# 
# 🏗️ HAUTE DISPONIBILITÉ:
#   - Support multi-répliques avec anti-affinité
#   - Configuration de réplication PostgreSQL
#   - Stratégies de placement intelligentes
#   - Gestion gracieuse des arrêts et redémarrages
# 
# 📊 MONITORING INTÉGRÉ:
#   - PostgreSQL Exporter pour métriques Prometheus
#   - Sondes de santé avancées avec multiples vérifications
#   - Annotations de monitoring automatiques
#   - Support des ServiceMonitor pour Prometheus Operator
# 
# 💾 GESTION DES DONNÉES:
#   - Stockage persistant avec support multi-classes
#   - Sauvegardes automatiques avec rétention configurable
#   - Compression et chiffrement des backups
#   - Support des scripts d'initialisation personnalisés
# 
# ⚡ PERFORMANCE:
#   - Configuration optimisée par environnement
#   - Gestion intelligente des ressources
#   - Support des volumes SSD haute performance
#   - Configuration mémoire adaptative
# 
# 🔧 OPÉRATIONS:
#   - Configuration centralisée via variables d'environnement
#   - Scripts de maintenance intégrés
#   - Logs structurés et debugging avancé
#   - Support des mises à jour rolling
  #
  # =========================================================================