---
# =========================================================================
# LIONS INFRASTRUCTURE 5.0 - DÃ‰PLOIEMENT REDIS
# =========================================================================
# Description: DÃ©ploie Redis sur Kubernetes avec haute disponibilitÃ©
# Version: 5.0.0
# Maintainer: DevOps Team LIONS
# Documentation: https://docs.lions.dev/infrastructure/services/redis
# =========================================================================

# =========================================================================
# MÃ‰TADONNÃ‰ES ET VALIDATION
# =========================================================================
- name: "ğŸ·ï¸  DÃ©finition des mÃ©tadonnÃ©es de dÃ©ploiement Redis"
  set_fact:
    redis_deploy_metadata:
      component: "redis"
      version: "{{ lookup('env', 'LIONS_REDIS_VERSION') | default('7.2', true) }}"
      namespace: "{{ lookup('env', 'LIONS_REDIS_NAMESPACE') | default('database', true) }}"
      environment: "{{ lookup('env', 'LIONS_ENVIRONMENT') | default('development', true) }}"
      deployment_timestamp: "{{ ansible_date_time.iso8601 }}"
      deployment_id: "{{ lookup('env', 'LIONS_DEPLOYMENT_ID') | default(ansible_date_time.epoch, true) }}"
    redis_service_config:
      name: "{{ lookup('env', 'LIONS_REDIS_SERVICE_NAME') | default('redis', true) }}"
      port: "{{ lookup('env', 'LIONS_REDIS_PORT') | default('6379', true) | int }}"
      storage_size: "{{ lookup('env', 'LIONS_REDIS_STORAGE_SIZE') | default('5Gi', true) }}"
      storage_class: "{{ lookup('env', 'LIONS_STORAGE_CLASS_DEFAULT') | default('local-path', true) }}"
    redis_resources:
      requests:
        cpu: "{{ lookup('env', 'LIONS_RESOURCES_SMALL_CPU_REQUEST') | default('100m', true) }}"
        memory: "{{ lookup('env', 'LIONS_RESOURCES_SMALL_MEMORY_REQUEST') | default('128Mi', true) }}"
      limits:
        cpu: "{{ lookup('env', 'LIONS_RESOURCES_SMALL_CPU_LIMIT') | default('500m', true) }}"
        memory: "{{ lookup('env', 'LIONS_RESOURCES_SMALL_MEMORY_LIMIT') | default('512Mi', true) }}"
    redis_timeouts:
      deployment: "{{ lookup('env', 'LIONS_TIMEOUT_DEPLOYMENT') | default('1800', true) | int }}"
      readiness: "{{ lookup('env', 'LIONS_TIMEOUT_DEFAULT') | default('300', true) | int }}"
      rollback: "{{ lookup('env', 'LIONS_TIMEOUT_ROLLBACK') | default('600', true) | int }}"

- name: "ğŸ” Validation des prÃ©requis de dÃ©ploiement Redis"
  assert:
    that:
      - redis_deploy_metadata.namespace is defined
      - redis_deploy_metadata.namespace | length > 0
      - redis_service_config.name is defined
      - redis_service_config.port > 0
      - redis_service_config.storage_size is defined
      - redis_resources.requests.cpu is defined
      - redis_resources.requests.memory is defined
    fail_msg: "âŒ PrÃ©requis manquants pour le dÃ©ploiement Redis"
    success_msg: "âœ… Validation des prÃ©requis Redis rÃ©ussie"

- name: "ğŸ“Š Affichage des informations de dÃ©ploiement Redis"
  debug:
    msg:
      - "ğŸš€ DÃ©ploiement Redis {{ redis_deploy_metadata.version }}"
      - "ğŸ“¦ Namespace: {{ redis_deploy_metadata.namespace }}"
      - "ğŸ·ï¸  Service: {{ redis_service_config.name }}"
      - "ğŸ”Œ Port: {{ redis_service_config.port }}"
      - "ğŸ’¾ Stockage: {{ redis_service_config.storage_size }}"
      - "ğŸŒ Environnement: {{ redis_deploy_metadata.environment }}"

# =========================================================================
# PRÃ‰PARATION DU DÃ‰PLOIEMENT
# =========================================================================
- name: "ğŸ“ VÃ©rification de l'existence du rÃ©pertoire temporaire"
  stat:
    path: "{{ temp_dir.path }}"
  register: temp_dir_stat

- name: "âŒ Ã‰chec si le rÃ©pertoire temporaire n'existe pas"
  fail:
    msg: "Le rÃ©pertoire temporaire {{ temp_dir.path }} n'existe pas"
  when: not temp_dir_stat.stat.exists

- name: "ğŸ”§ VÃ©rification de la connectivitÃ© Kubernetes"
  k8s_info:
    api_version: v1
    kind: Namespace
    name: "{{ redis_deploy_metadata.namespace }}"
  register: namespace_check
  failed_when: false

- name: "ğŸ—ï¸  CrÃ©ation du namespace Redis si nÃ©cessaire"
  k8s:
    name: "{{ redis_deploy_metadata.namespace }}"
    api_version: v1
    kind: Namespace
    state: present
    definition:
      metadata:
        labels:
          app.kubernetes.io/name: "{{ redis_service_config.name }}"
          app.kubernetes.io/component: "database"
          app.kubernetes.io/part-of: "lions-infrastructure"
          lions.dev/environment: "{{ redis_deploy_metadata.environment }}"
          lions.dev/managed-by: "ansible"
  when: namespace_check.resources | length == 0

# =========================================================================
# GESTION DES SECRETS ET CONFIGURATION
# =========================================================================
- name: "ğŸ” GÃ©nÃ©ration du mot de passe Redis (si activÃ©)"
  set_fact:
    redis_auth_enabled: "{{ lookup('env', 'LIONS_REDIS_AUTH_ENABLED') | default('true', true) | bool }}"
    redis_password: "{{ lookup('env', 'LIONS_REDIS_PASSWORD') | default(lookup('password', '/dev/null chars=ascii_letters,digits length=32'), true) }}"
  when: lookup('env', 'LIONS_REDIS_AUTH_ENABLED') | default('true', true) | bool

- name: "ğŸ”‘ CrÃ©ation du secret Redis"
  k8s:
    state: present
    definition:
      apiVersion: v1
      kind: Secret
      metadata:
        name: "{{ redis_service_config.name }}-secret"
        namespace: "{{ redis_deploy_metadata.namespace }}"
        labels:
          app.kubernetes.io/name: "{{ redis_service_config.name }}"
          app.kubernetes.io/component: "database"
          lions.dev/managed-by: "ansible"
      type: Opaque
      data:
        redis-password: "{{ redis_password | b64encode }}"
  when: redis_auth_enabled | default(true)

# =========================================================================
# DÃ‰PLOIEMENT DES RESSOURCES KUBERNETES
# =========================================================================
- name: "ğŸ“¦ DÃ©ploiement du PersistentVolumeClaim Redis"
  k8s:
    state: present
    src: "{{ temp_dir.path }}/persistentvolumeclaim.yml"
  register: pvc_result

- name: "âš™ï¸  DÃ©ploiement de la ConfigMap Redis"
  k8s:
    state: present
    src: "{{ temp_dir.path }}/configmap.yml"
  register: configmap_result

- name: "ğŸ‘¤ DÃ©ploiement du ServiceAccount Redis"
  k8s:
    state: present
    src: "{{ temp_dir.path }}/serviceaccount.yml"
  register: serviceaccount_result

- name: "ğŸš€ DÃ©ploiement du StatefulSet Redis"
  k8s:
    state: present
    src: "{{ temp_dir.path }}/statefulset.yml"
  register: statefulset_result

- name: "ğŸŒ CrÃ©ation du Service Redis"
  k8s:
    state: present
    src: "{{ temp_dir.path }}/service.yml"
  register: service_result

# =========================================================================
# MONITORING ET OBSERVABILITÃ‰
# =========================================================================
- name: "ğŸ“Š DÃ©ploiement du ServiceMonitor Redis (si monitoring activÃ©)"
  k8s:
    state: present
    src: "{{ temp_dir.path }}/servicemonitor.yml"
  register: servicemonitor_result
  when: lookup('env', 'LIONS_MONITORING_ENABLED') | default('true', true) | bool

# =========================================================================
# ATTENTE ET VALIDATION DU DÃ‰PLOIEMENT
# =========================================================================
- name: "â³ Attente de la disponibilitÃ© du StatefulSet Redis"
  k8s_info:
    api_version: apps/v1
    kind: StatefulSet
    namespace: "{{ redis_deploy_metadata.namespace }}"
    name: "{{ redis_service_config.name }}"
  register: statefulset_status
  until: >
    statefulset_status.resources | length > 0 and
    statefulset_status.resources[0].status.readyReplicas is defined and
    statefulset_status.resources[0].status.readyReplicas == statefulset_status.resources[0].spec.replicas
  retries: "{{ (redis_timeouts.deployment / 30) | int }}"
  delay: 30
  failed_when: false

- name: "ğŸ” Validation du statut de dÃ©ploiement du StatefulSet"
  fail:
    msg: "âŒ Le dÃ©ploiement du StatefulSet Redis a Ã©chouÃ© aprÃ¨s {{ redis_timeouts.deployment }}s"
  when: >
    statefulset_status.failed or
    statefulset_status.resources | length == 0 or
    (statefulset_status.resources[0].status.readyReplicas | default(0)) != (statefulset_status.resources[0].spec.replicas | default(1))

- name: "ğŸ“‹ RÃ©cupÃ©ration des informations des pods Redis"
  k8s_info:
    api_version: v1
    kind: Pod
    namespace: "{{ redis_deploy_metadata.namespace }}"
    label_selectors:
      - "app.kubernetes.io/name={{ redis_service_config.name }}"
  register: redis_pods_info

- name: "ğŸ“Š Affichage du statut des pods Redis"
  debug:
    msg: "Pod {{ item.metadata.name }} - Ã‰tat: {{ item.status.phase }} - PrÃªt: {{ item.status.conditions | selectattr('type', 'equalto', 'Ready') | map(attribute='status') | first | default('Unknown') }}"
  loop: "{{ redis_pods_info.resources }}"
  loop_control:
    label: "{{ item.metadata.name }}"

# =========================================================================
# TESTS DE SANTÃ‰ ET CONNECTIVITÃ‰
# =========================================================================
- name: "â¸ï¸  Attente de l'initialisation complÃ¨te de Redis"
  pause:
    seconds: "{{ lookup('env', 'LIONS_REDIS_INIT_DELAY') | default('30', true) | int }}"

- name: "ğŸ©º Test de connectivitÃ© Redis"
  shell: |
    kubectl exec -n {{ redis_deploy_metadata.namespace }} {{ redis_pods_info.resources[0].metadata.name }} -- \
    {% if redis_auth_enabled | default(true) %}
    redis-cli -a "{{ redis_password }}" ping
    {% else %}
    redis-cli ping
    {% endif %}
  register: redis_ping_test
  retries: "{{ (redis_timeouts.readiness / 10) | int }}"
  delay: 10
  until: redis_ping_test.rc == 0 and redis_ping_test.stdout.strip() == "PONG"
  failed_when: false
  changed_when: false
  no_log: "{{ redis_auth_enabled | default(true) }}"

- name: "âš ï¸  Gestion de l'Ã©chec du test de connectivitÃ©"
  block:
    - name: "ğŸ“‹ RÃ©cupÃ©ration des logs d'erreur Redis"
      shell: "kubectl logs -n {{ redis_deploy_metadata.namespace }} {{ redis_pods_info.resources[0].metadata.name }} --tail=50"
      register: redis_error_logs
      failed_when: false

    - name: "âŒ Affichage des logs d'erreur"
      debug:
        msg: "Logs d'erreur Redis: {{ redis_error_logs.stdout_lines | default(['Aucun log disponible']) }}"

    - name: "ğŸ”„ Tentative de redÃ©marrage du pod Redis"
      shell: "kubectl delete pod -n {{ redis_deploy_metadata.namespace }} {{ redis_pods_info.resources[0].metadata.name }}"
      when: lookup('env', 'LIONS_AUTO_RECOVERY_ENABLED') | default('true', true) | bool

    - name: "âŒ Ã‰chec critique du dÃ©ploiement Redis"
      fail:
        msg: "âŒ Redis n'est pas disponible aprÃ¨s {{ redis_timeouts.readiness }}s. Consultez les logs pour plus d'informations."
  when: redis_ping_test.failed or redis_ping_test.rc != 0

# =========================================================================
# VALIDATION DE LA CONFIGURATION REDIS
# =========================================================================
- name: "ğŸ”§ VÃ©rification de la configuration Redis"
  shell: |
    kubectl exec -n {{ redis_deploy_metadata.namespace }} {{ redis_pods_info.resources[0].metadata.name }} -- \
    {% if redis_auth_enabled | default(true) %}
    redis-cli -a "{{ redis_password }}" config get maxmemory
    {% else %}
    redis-cli config get maxmemory
    {% endif %}
  register: redis_config_check
  failed_when: false
  changed_when: false
  no_log: "{{ redis_auth_enabled | default(true) }}"

- name: "ğŸ“Š Affichage de la configuration Redis"
  debug:
    msg:
      - "ğŸ’¾ MÃ©moire maximale configurÃ©e: {{ redis_config_check.stdout_lines[1] if redis_config_check.rc == 0 and redis_config_check.stdout_lines | length > 1 else 'Non configurÃ©e' }}"
      - "ğŸ”§ Version Redis: {{ redis_deploy_metadata.version }}"
      - "ğŸ”Œ Port d'Ã©coute: {{ redis_service_config.port }}"

# =========================================================================
# TESTS DE PERFORMANCE ET SÃ‰CURITÃ‰
# =========================================================================
- name: "ğŸ”’ Test de sÃ©curitÃ© - VÃ©rification de l'authentification"
  shell: |
    kubectl exec -n {{ redis_deploy_metadata.namespace }} {{ redis_pods_info.resources[0].metadata.name }} -- \
    redis-cli ping
  register: redis_security_test
  failed_when: false
  changed_when: false
  when: redis_auth_enabled | default(true)

- name: "âœ… Validation de la sÃ©curitÃ© Redis"
  debug:
    msg: "ğŸ” Authentification Redis correctement configurÃ©e"
  when: redis_auth_enabled | default(true) and redis_security_test.rc != 0

- name: "âš ï¸  Avertissement de sÃ©curitÃ© Redis"
  debug:
    msg: "âš ï¸  ATTENTION: Redis fonctionne sans authentification - Risque de sÃ©curitÃ©!"
  when: not (redis_auth_enabled | default(true))

# =========================================================================
# TESTS DE CLUSTERING (SI ACTIVÃ‰)
# =========================================================================
- name: "ğŸ”— Test du cluster Redis (si activÃ©)"
  block:
    - name: "ğŸ“Š VÃ©rification des informations du cluster Redis"
      shell: |
        kubectl exec -n {{ redis_deploy_metadata.namespace }} {{ redis_pods_info.resources[0].metadata.name }} -- \
        {% if redis_auth_enabled | default(true) %}
        redis-cli -a "{{ redis_password }}" cluster info
        {% else %}
        redis-cli cluster info
        {% endif %}
      register: redis_cluster_info
      failed_when: false
      changed_when: false
      no_log: "{{ redis_auth_enabled | default(true) }}"

    - name: "ğŸ“‹ Affichage des informations du cluster"
      debug:
        msg: "Cluster Redis: {{ redis_cluster_info.stdout_lines | default(['Cluster non configurÃ©']) }}"
  when: lookup('env', 'LIONS_REDIS_CLUSTER_ENABLED') | default('false', true) | bool

# =========================================================================
# FINALISATION ET REPORTING
# =========================================================================
- name: "ğŸ“Š RÃ©cupÃ©ration des mÃ©triques de dÃ©ploiement"
  set_fact:
    redis_deployment_metrics:
      deployment_duration: "{{ (ansible_date_time.epoch | int) - (redis_deploy_metadata.deployment_id | int) }}"
      pods_ready: "{{ redis_pods_info.resources | selectattr('status.phase', 'equalto', 'Running') | list | length }}"
      pods_total: "{{ redis_pods_info.resources | length }}"
      pvc_status: "{{ pvc_result.result.status.phase | default('Unknown') }}"
      service_ready: "{{ service_result is succeeded }}"
      monitoring_enabled: "{{ lookup('env', 'LIONS_MONITORING_ENABLED') | default('true', true) | bool }}"

- name: "ğŸ“‹ GÃ©nÃ©ration du rapport de dÃ©ploiement Redis"
  debug:
    msg:
      - "ğŸ‰ ======= DÃ‰PLOIEMENT REDIS TERMINÃ‰ ======="
      - "ğŸ“Š Version dÃ©ployÃ©e: {{ redis_deploy_metadata.version }}"
      - "ğŸ·ï¸  Service: {{ redis_service_config.name }}"
      - "ğŸ“¦ Namespace: {{ redis_deploy_metadata.namespace }}"
      - "â±ï¸  DurÃ©e du dÃ©ploiement: {{ redis_deployment_metrics.deployment_duration }}s"
      - "ğŸš€ Pods prÃªts: {{ redis_deployment_metrics.pods_ready }}/{{ redis_deployment_metrics.pods_total }}"
      - "ğŸ’¾ Stockage: {{ redis_deployment_metrics.pvc_status }}"
      - "ğŸŒ Service: {{ 'Actif' if redis_deployment_metrics.service_ready else 'Inactif' }}"
      - "ğŸ“Š Monitoring: {{ 'ActivÃ©' if redis_deployment_metrics.monitoring_enabled else 'DÃ©sactivÃ©' }}"
      - "ğŸ” Authentification: {{ 'ActivÃ©e' if redis_auth_enabled | default(true) else 'DÃ©sactivÃ©e' }}"
      - "==========================================="

- name: "âœ… Marquer le dÃ©ploiement comme rÃ©ussi"
  set_fact:
    redis_deployment_status: "success"
    redis_deployment_completed_at: "{{ ansible_date_time.iso8601 }}"

# =========================================================================
# GESTION D'ERREUR ET ROLLBACK
# =========================================================================
- rescue:
  - name: "âŒ Gestion d'erreur lors du dÃ©ploiement Redis"
    debug:
      msg:
        - "âŒ ERREUR: Ã‰chec du dÃ©ploiement Redis"
        - "ğŸ” Cause: {{ ansible_failed_result.msg | default('Erreur inconnue') }}"
        - "â° Timestamp: {{ ansible_date_time.iso8601 }}"

  - name: "ğŸ”„ Tentative de rollback automatique (si activÃ©)"
    include_tasks: rollback.yml
    when: lookup('env', 'LIONS_AUTO_ROLLBACK_ENABLED') | default('false', true) | bool

  - name: "ğŸ“‹ Collecte des informations de debug"
    shell: |
      echo "=== Informations de debug Redis ==="
      kubectl get all -n {{ redis_deploy_metadata.namespace }} -l app.kubernetes.io/name={{ redis_service_config.name }}
      echo "=== Logs du dernier pod ==="
      kubectl logs -n {{ redis_deploy_metadata.namespace }} -l app.kubernetes.io/name={{ redis_service_config.name }} --tail=100
    register: debug_info
    failed_when: false

  - name: "ğŸ“„ Affichage des informations de debug"
    debug:
      msg: "{{ debug_info.stdout_lines | default(['Aucune information de debug disponible']) }}"

  - name: "âŒ Ã‰chec final du dÃ©ploiement"
    fail:
      msg: "âŒ Le dÃ©ploiement Redis a Ã©chouÃ© de maniÃ¨re critique"

- always:
  - name: "ğŸ§¹ Nettoyage des ressources temporaires"
    file:
      path: "{{ item }}"
      state: absent
    loop:
      - "{{ temp_dir.path }}/redis-temp-password"
    failed_when: false