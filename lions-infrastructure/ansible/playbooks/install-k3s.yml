---
# Titre: Playbook d'installation de K3s
# Description: Installe et configure K3s sur le VPS
# Auteur: Équipe LIONS Infrastructure
# Date: 2023-05-15
# Version: 1.0.0

- name: Installation de K3s sur le VPS
  hosts: vps
  become: yes

  vars:
    k3s_version: "v1.25.6+k3s1"  # Version stable de K3s
    k3s_server_args: "--disable-cloud-controller --kube-controller-manager-arg bind-address=0.0.0.0 --kube-scheduler-arg bind-address=0.0.0.0 --disable traefik"
    kubeconfig_local_path: "~/.kube/config"
    traefik_version: "20.10.0"  # Version sans le préfixe 'v'

  tasks:
    - name: Vérification de l'installation existante de K3s
      stat:
        path: /usr/local/bin/k3s
      register: k3s_binary

    - name: Téléchargement du script d'installation K3s
      get_url:
        url: https://get.k3s.io
        dest: /tmp/k3s-install.sh
        mode: '0755'
      when: not k3s_binary.stat.exists

    - name: Installation de K3s
      environment:
        INSTALL_K3S_VERSION: "{{ k3s_version }}"
        INSTALL_K3S_EXEC: "{{ k3s_server_args }}"
      command: /tmp/k3s-install.sh
      args:
        creates: /usr/local/bin/k3s
      register: k3s_installed
      when: not k3s_binary.stat.exists

    - name: Attente que K3s soit prêt
      wait_for:
        path: /var/lib/rancher/k3s/server/node-token
        state: present
        delay: 10
        timeout: 300
      when: k3s_installed.changed

    - name: Vérification de l'état du service K3s
      service:
        name: k3s
        state: started
        enabled: yes
      register: k3s_service_status

    - name: Affichage de l'état du service K3s
      debug:
        msg: "État du service K3s: {{ k3s_service_status.status.ActiveState | default('inconnu') }}"

    - name: Redémarrage du service K3s si nécessaire
      service:
        name: k3s
        state: restarted
      register: k3s_restart_result
      when: k3s_service_status.status.ActiveState is defined and k3s_service_status.status.ActiveState != "active"
      ignore_errors: yes

    - name: Vérification des journaux K3s en cas d'échec de redémarrage
      shell: journalctl -u k3s -n 50 --no-pager
      register: k3s_logs
      when: k3s_restart_result is defined and k3s_restart_result.failed is defined and k3s_restart_result.failed

    - name: Affichage des journaux K3s en cas d'échec
      debug:
        msg: "{{ k3s_logs.stdout_lines }}"
      when: k3s_logs is defined and k3s_logs.stdout_lines is defined

    - name: Tentative de correction des problèmes courants de K3s
      block:
        - name: Vérification des ports utilisés
          shell: netstat -tulpn | grep 6443 || echo "Port 6443 libre"
          register: port_check

        - name: Affichage des ports utilisés
          debug:
            msg: "{{ port_check.stdout_lines }}"

        - name: Vérification de la mémoire disponible
          shell: free -m
          register: memory_check

        - name: Affichage de la mémoire disponible
          debug:
            msg: "{{ memory_check.stdout_lines }}"

        - name: Correction des permissions des fichiers K3s
          shell: |
            chmod -R 755 /var/lib/rancher/k3s 2>/dev/null || true
            chmod 600 /etc/rancher/k3s/k3s.yaml 2>/dev/null || true

        - name: Rechargement du daemon systemd
          systemd:
            daemon_reload: yes

        - name: Nouvelle tentative de redémarrage du service K3s
          service:
            name: k3s
            state: restarted
          register: k3s_retry_restart

      when: k3s_restart_result is defined and k3s_restart_result.failed is defined and k3s_restart_result.failed

    - name: Vérification finale de l'état du service K3s
      shell: systemctl status k3s
      register: k3s_final_status
      ignore_errors: yes
      when: (k3s_restart_result is defined and k3s_restart_result.failed is defined and k3s_restart_result.failed) or
            (k3s_retry_restart is defined and k3s_retry_restart.failed is defined and k3s_retry_restart.failed)

    - name: Affichage de l'état final du service K3s
      debug:
        msg: "État final du service K3s: {{ k3s_final_status.stdout_lines | default(['État inconnu']) }}"
      when: k3s_final_status is defined

    - name: Vérification des processus K3s en cours d'exécution
      shell: ps aux | grep k3s | grep -v grep || echo "Aucun processus K3s en cours d'exécution"
      register: k3s_processes
      when: (k3s_restart_result is defined and k3s_restart_result.failed is defined and k3s_restart_result.failed) or
            (k3s_retry_restart is defined and k3s_retry_restart.failed is defined and k3s_retry_restart.failed)

    - name: Affichage des processus K3s
      debug:
        msg: "Processus K3s en cours d'exécution: {{ k3s_processes.stdout_lines | default(['Aucun']) }}"
      when: k3s_processes is defined

    - name: Vérification spécifique pour l'erreur "control process exited with error code"
      block:
        - name: Vérification des dépendances du binaire K3s
          shell: ldd /usr/local/bin/k3s || echo "Impossible de vérifier les dépendances"
          register: k3s_dependencies

        - name: Affichage des dépendances du binaire K3s
          debug:
            msg: "Dépendances du binaire K3s: {{ k3s_dependencies.stdout_lines }}"

        - name: Vérification des permissions du binaire K3s
          shell: ls -la /usr/local/bin/k3s
          register: k3s_permissions

        - name: Affichage des permissions du binaire K3s
          debug:
            msg: "Permissions du binaire K3s: {{ k3s_permissions.stdout_lines }}"

        - name: Vérification de l'intégrité du binaire K3s
          shell: file /usr/local/bin/k3s
          register: k3s_file_info

        - name: Affichage des informations sur le binaire K3s
          debug:
            msg: "Informations sur le binaire K3s: {{ k3s_file_info.stdout_lines }}"

        - name: Tentative de réparation du binaire K3s
          shell: "cp /usr/local/bin/k3s /usr/local/bin/k3s.bak && curl -sfL https://get.k3s.io -o /tmp/k3s-install.sh && chmod +x /tmp/k3s-install.sh && INSTALL_K3S_SKIP_START=true /tmp/k3s-install.sh"
          when: k3s_final_status.stdout is defined and k3s_final_status.stdout is search("control process exited with error code")
          register: k3s_repair_attempt

        - name: Affichage du résultat de la tentative de réparation
          debug:
            msg: "Résultat de la tentative de réparation: {{ k3s_repair_attempt.stdout_lines | default(['Aucune réparation effectuée']) }}"
          when: k3s_repair_attempt is defined

      when: k3s_final_status is defined and k3s_final_status.stdout is defined and k3s_final_status.stdout is search("control process exited with error code")

    - name: Tentative finale de redémarrage du service K3s après diagnostics et réparations
      service:
        name: k3s
        state: restarted
      register: k3s_final_restart
      ignore_errors: yes
      when: (k3s_restart_result is defined and k3s_restart_result.failed is defined and k3s_restart_result.failed) or
            (k3s_retry_restart is defined and k3s_retry_restart.failed is defined and k3s_retry_restart.failed) or
            (k3s_repair_attempt is defined)

    - name: Vérification ultime de l'état du service K3s
      shell: systemctl status k3s
      register: k3s_ultimate_status
      ignore_errors: yes
      when: k3s_final_restart is defined

    - name: Affichage de l'état ultime du service K3s
      debug:
        msg: "État ultime du service K3s après toutes les tentatives: {{ k3s_ultimate_status.stdout_lines | default(['État inconnu']) }}"
      when: k3s_ultimate_status is defined

    - name: Notification de résultat final
      debug:
        msg: >
          {% if k3s_ultimate_status is defined and k3s_ultimate_status.rc == 0 %}
          Le service K3s a été démarré avec succès après plusieurs tentatives.
          {% else %}
          Le service K3s n'a pas pu être démarré malgré plusieurs tentatives. Veuillez consulter les journaux pour plus d'informations.
          {% endif %}

    - name: Attente que le serveur API K3s soit prêt
      wait_for:
        port: 6443
        delay: 10
        timeout: 300
      when: (k3s_installed.changed or k3s_service_status.changed) and 
            not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0)

    - name: Création du répertoire .kube pour l'utilisateur
      file:
        path: /home/{{ ansible_user }}/.kube
        state: directory
        mode: '0755'
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
      when: not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0)

    - name: Vérification de l'existence du fichier kubeconfig
      stat:
        path: /etc/rancher/k3s/k3s.yaml
      register: k3s_kubeconfig
      when: not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0)

    - name: Copie du fichier kubeconfig pour l'utilisateur
      copy:
        src: /etc/rancher/k3s/k3s.yaml
        dest: /home/{{ ansible_user }}/.kube/config
        remote_src: yes
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'
      when: not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0) and
            (k3s_kubeconfig is defined and k3s_kubeconfig.stat.exists)

    - name: Mise à jour du fichier kubeconfig avec l'adresse IP externe
      replace:
        path: /home/{{ ansible_user }}/.kube/config
        regexp: 'https://127.0.0.1:6443'
        replace: 'https://{{ ansible_host }}:6443'
      when: not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0) and
            (k3s_kubeconfig is defined and k3s_kubeconfig.stat.exists)

    - name: Configuration de l'accès à kubectl
      lineinfile:
        path: /home/{{ ansible_user }}/.bashrc
        line: 'export KUBECONFIG=/home/{{ ansible_user }}/.kube/config'
        state: present
      when: not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0)

    - name: Installation de kubectl
      block:
        - name: Ajout de la clé GPG de Kubernetes
          apt_key:
            url: https://packages.cloud.google.com/apt/doc/apt-key.gpg
            state: present

        - name: Ajout du dépôt Kubernetes
          apt_repository:
            repo: deb https://apt.kubernetes.io/ kubernetes-focal main
            state: present
            filename: kubernetes

        - name: Installation de kubectl
          apt:
            name: kubectl
            state: present
            update_cache: yes
      when: not k3s_binary.stat.exists and not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0)

    - name: Récupération du fichier kubeconfig pour utilisation locale
      fetch:
        src: /home/{{ ansible_user }}/.kube/config
        dest: "{{ kubeconfig_local_path }}"
        flat: yes
      when: kubeconfig_local_path is defined and 
            not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0) and
            (k3s_kubeconfig is defined and k3s_kubeconfig.stat.exists)

    - name: Installation de Helm
      block:
        - name: Téléchargement du script d'installation de Helm
          get_url:
            url: https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
            dest: /tmp/get-helm-3.sh
            mode: '0755'

        - name: Exécution du script d'installation de Helm
          command: /tmp/get-helm-3.sh
          args:
            creates: /usr/local/bin/helm

        - name: Configuration de Helm pour utiliser le bon kubeconfig
          lineinfile:
            path: /home/{{ ansible_user }}/.bashrc
            line: 'export KUBECONFIG=/home/{{ ansible_user }}/.kube/config'
            state: present

        # Pas besoin de recharger l'environnement, on va utiliser le paramètre environment pour les tâches Helm

        - name: Vérification que le répertoire /root/.kube existe
          file:
            path: /root/.kube
            state: directory
            mode: '0755'
          become: yes
          when: k3s_kubeconfig is defined and k3s_kubeconfig.stat.exists

        - name: Création d'un lien symbolique pour le kubeconfig dans /root/.kube
          file:
            src: /home/{{ ansible_user }}/.kube/config
            dest: /root/.kube/config
            state: link
            force: yes
          become: yes
          when: k3s_kubeconfig is defined and k3s_kubeconfig.stat.exists
      when: not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0)

    - name: Vérification de l'installation de K3s
      command: k3s kubectl get nodes
      register: k3s_nodes
      changed_when: false
      environment:
        KUBECONFIG: /home/{{ ansible_user }}/.kube/config
      when: not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0) and
            (k3s_kubeconfig is defined and k3s_kubeconfig.stat.exists)
      ignore_errors: yes

    - name: Affichage des nœuds K3s
      debug:
        var: k3s_nodes.stdout_lines
      when: k3s_nodes is defined and k3s_nodes.stdout_lines is defined

    - name: Vérification des pods système
      command: k3s kubectl get pods -n kube-system
      register: k3s_system_pods
      changed_when: false
      environment:
        KUBECONFIG: /home/{{ ansible_user }}/.kube/config
      when: not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0) and
            (k3s_kubeconfig is defined and k3s_kubeconfig.stat.exists)
      ignore_errors: yes

    - name: Affichage des pods système
      debug:
        var: k3s_system_pods.stdout_lines
      when: k3s_system_pods is defined and k3s_system_pods.stdout_lines is defined

    - name: Installation des dépendances Python pour Kubernetes
      pip:
        name:
          - kubernetes
          - openshift
        state: present
      become: yes
      when: not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0)

    - name: Installation de Traefik via Helm
      block:
        - name: Ajout du dépôt Helm de Traefik
          kubernetes.core.helm_repository:
            name: traefik
            repo_url: https://helm.traefik.io/traefik
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Mise à jour des dépôts Helm
          command: helm repo update
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Création du namespace traefik
          kubernetes.core.k8s:
            name: traefik
            api_version: v1
            kind: Namespace
            state: present
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Déploiement de Traefik via Helm
          kubernetes.core.helm:
            name: traefik
            chart_ref: traefik/traefik
            chart_version: "{{ traefik_version }}"
            release_namespace: traefik
            create_namespace: true
            wait: true
            values:
              ports:
                web:
                  port: 80
                  expose: true
                  exposedPort: 80
                  protocol: TCP
                websecure:
                  port: 443
                  expose: true
                  exposedPort: 443
                  protocol: TCP
              service:
                type: LoadBalancer
                externalIPs:
                  - "{{ ansible_host }}"
              ingressClass:
                enabled: true
                isDefaultClass: true
              logs:
                general:
                  level: INFO
                access:
                  enabled: true
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Attente que Traefik soit prêt
          kubernetes.core.k8s_info:
            api_version: v1
            kind: Pod
            namespace: traefik
            label_selectors:
              - app.kubernetes.io/name=traefik
          register: traefik_pods
          until: traefik_pods.resources | length > 0 and (traefik_pods.resources[0].status.phase == 'Running')
          retries: 30
          delay: 10
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Vérification de l'accès à Traefik
          uri:
            url: "http://{{ ansible_host }}"
            method: GET
            status_code: 200, 404, 503
            validate_certs: no
          register: traefik_access
          ignore_errors: yes

        - name: Affichage du statut d'accès à Traefik
          debug:
            msg: "Traefik est {{ 'accessible' if traefik_access is succeeded else 'inaccessible' }} à l'adresse http://{{ ansible_host }}"
      when: not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0) and
            (k3s_kubeconfig is defined and k3s_kubeconfig.stat.exists)

    - name: Installation de MetalLB pour le LoadBalancer
      block:
        - name: Création du namespace metallb-system
          kubernetes.core.k8s:
            name: metallb-system
            api_version: v1
            kind: Namespace
            state: present
            host: "https://{{ ansible_host }}:6443"
            validate_certs: false
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Déploiement de MetalLB via Helm
          kubernetes.core.helm:
            name: metallb
            chart_ref: metallb/metallb
            release_namespace: metallb-system
            create_namespace: true
            wait: true
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Configuration de l'IPAddressPool pour MetalLB
          kubernetes.core.k8s:
            state: present
            definition:
              apiVersion: metallb.io/v1beta1
              kind: IPAddressPool
              metadata:
                name: first-pool
                namespace: metallb-system
              spec:
                addresses:
                  - "{{ ansible_host }}/32"  # Utilise l'adresse IP du VPS
            host: "https://{{ ansible_host }}:6443"
            validate_certs: false
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Configuration de L2Advertisement pour MetalLB
          kubernetes.core.k8s:
            state: present
            definition:
              apiVersion: metallb.io/v1beta1
              kind: L2Advertisement
              metadata:
                name: l2-advert
                namespace: metallb-system
              spec:
                ipAddressPools:
                  - first-pool
            host: "https://{{ ansible_host }}:6443"
            validate_certs: false
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config
      when: k3s_installed.changed and not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0) and
            (k3s_kubeconfig is defined and k3s_kubeconfig.stat.exists)

    - name: Installation de cert-manager pour les certificats TLS
      block:
        - name: Ajout du dépôt Helm de cert-manager
          kubernetes.core.helm_repository:
            name: jetstack
            repo_url: https://charts.jetstack.io
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Déploiement de cert-manager via Helm
          kubernetes.core.helm:
            name: cert-manager
            chart_ref: jetstack/cert-manager
            release_namespace: cert-manager
            create_namespace: true
            wait: true
            values:
              installCRDs: true
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config
      when: not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0) and
            (k3s_kubeconfig is defined and k3s_kubeconfig.stat.exists)

    # Traefik est maintenant utilisé comme contrôleur d'ingress par défaut
    # Le bloc d'installation de Nginx Ingress Controller a été supprimé
    # Traefik est installé automatiquement avec K3s

    - name: Installation du Kubernetes Dashboard
      block:
        - name: Création du namespace kubernetes-dashboard
          kubernetes.core.k8s:
            name: kubernetes-dashboard
            api_version: v1
            kind: Namespace
            state: present
            host: "https://{{ ansible_host }}:6443"
            validate_certs: false
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Déploiement du Kubernetes Dashboard
          shell: kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Création du Service NodePort pour exposer le Dashboard
          kubernetes.core.k8s:
            state: present
            definition:
              apiVersion: v1
              kind: Service
              metadata:
                name: kubernetes-dashboard-nodeport
                namespace: kubernetes-dashboard
              spec:
                ports:
                - port: 443
                  targetPort: 8443
                  nodePort: 30001
                selector:
                  k8s-app: kubernetes-dashboard
                type: NodePort
            host: "https://{{ ansible_host }}:6443"
            validate_certs: false
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Création d'un compte de service avec droits d'administration
          kubernetes.core.k8s:
            state: present
            definition:
              apiVersion: v1
              kind: ServiceAccount
              metadata:
                name: dashboard-admin
                namespace: kubernetes-dashboard
            host: "https://{{ ansible_host }}:6443"
            validate_certs: false
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Création d'un ClusterRoleBinding pour le compte admin
          kubernetes.core.k8s:
            state: present
            definition:
              apiVersion: rbac.authorization.k8s.io/v1
              kind: ClusterRoleBinding
              metadata:
                name: dashboard-admin
              roleRef:
                apiGroup: rbac.authorization.k8s.io
                kind: ClusterRole
                name: cluster-admin
              subjects:
              - kind: ServiceAccount
                name: dashboard-admin
                namespace: kubernetes-dashboard
            host: "https://{{ ansible_host }}:6443"
            validate_certs: false
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Création de l'Ingress pour le Kubernetes Dashboard (Production)
          kubernetes.core.k8s:
            state: present
            definition:
              apiVersion: networking.k8s.io/v1
              kind: Ingress
              metadata:
                name: kubernetes-dashboard-prod
                namespace: kubernetes-dashboard
                annotations:
                  cert-manager.io/cluster-issuer: letsencrypt-prod
                  traefik.ingress.kubernetes.io/router.entrypoints: "websecure"
                  traefik.ingress.kubernetes.io/router.tls: "true"
                  traefik.ingress.kubernetes.io/router.middlewares: "kubernetes-dashboard-strip-prefix@kubernetescrd"
              spec:
                ingressClassName: traefik
                tls:
                  - hosts:
                      - "k3s.lions.dev"
                    secretName: kubernetes-dashboard-tls-prod
                rules:
                  - host: "k3s.lions.dev"
                    http:
                      paths:
                        - path: /
                          pathType: Prefix
                          backend:
                            service:
                              name: kubernetes-dashboard
                              port:
                                number: 443
            host: "https://{{ ansible_host }}:6443"
            validate_certs: false
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Création de l'Ingress pour le Kubernetes Dashboard (Développement)
          kubernetes.core.k8s:
            state: present
            definition:
              apiVersion: networking.k8s.io/v1
              kind: Ingress
              metadata:
                name: kubernetes-dashboard-dev
                namespace: kubernetes-dashboard
                annotations:
                  cert-manager.io/cluster-issuer: letsencrypt-staging
                  traefik.ingress.kubernetes.io/router.entrypoints: "websecure"
                  traefik.ingress.kubernetes.io/router.tls: "true"
                  traefik.ingress.kubernetes.io/router.middlewares: "kubernetes-dashboard-strip-prefix@kubernetescrd"
              spec:
                ingressClassName: traefik
                tls:
                  - hosts:
                      - "k3s.dev.lions.dev"
                    secretName: kubernetes-dashboard-tls-dev
                rules:
                  - host: "k3s.dev.lions.dev"
                    http:
                      paths:
                        - path: /
                          pathType: Prefix
                          backend:
                            service:
                              name: kubernetes-dashboard
                              port:
                                number: 443
            host: "https://{{ ansible_host }}:6443"
            validate_certs: false
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Installation des CRDs Traefik
          shell: kubectl apply -f https://raw.githubusercontent.com/traefik/traefik/v2.10/docs/content/reference/dynamic-configuration/kubernetes-crd-definition-v1.yml
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Création du middleware pour le Dashboard
          kubernetes.core.k8s:
            state: present
            definition:
              apiVersion: traefik.io/v1alpha1
              kind: Middleware
              metadata:
                name: kubernetes-dashboard-strip-prefix
                namespace: kubernetes-dashboard
              spec:
                stripPrefix:
                  prefixes:
                    - "/dashboard"
            host: "https://{{ ansible_host }}:6443"
            validate_certs: false
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Création d'un Secret pour le token permanent du Dashboard
          kubernetes.core.k8s:
            state: present
            definition:
              apiVersion: v1
              kind: Secret
              metadata:
                name: dashboard-admin-token
                namespace: kubernetes-dashboard
                annotations:
                  kubernetes.io/service-account.name: dashboard-admin
              type: kubernetes.io/service-account-token
            host: "https://{{ ansible_host }}:6443"
            validate_certs: false
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config
          register: dashboard_secret

        - name: Attente que le token soit généré
          pause:
            seconds: 5

        - name: Récupération du token permanent
          shell: k3s kubectl get secret dashboard-admin-token -n kubernetes-dashboard -o jsonpath='{.data.token}' | base64 --decode
          register: dashboard_token
          changed_when: false
          environment:
            KUBECONFIG: /home/{{ ansible_user }}/.kube/config

        - name: Affichage du token permanent pour l'accès au Dashboard
          debug:
            msg: "Token permanent pour l'accès au Kubernetes Dashboard: {{ dashboard_token.stdout }}"
      when: not (k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0) and
            (k3s_kubeconfig is defined and k3s_kubeconfig.stat.exists)

    - name: Vérification finale de l'installation
      debug:
        msg: >
          {% if k3s_ultimate_status is defined and k3s_ultimate_status.rc != 0 %}
          L'installation de K3s a rencontré des problèmes. Veuillez consulter les journaux pour plus d'informations.
          {% else %}
          K3s a été installé avec succès sur le VPS et est prêt à recevoir les applications.
          {% endif %}
