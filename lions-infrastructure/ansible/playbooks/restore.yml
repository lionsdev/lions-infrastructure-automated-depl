---
# ===============================================================================
# LIONS INFRASTRUCTURE - RESTORE PLAYBOOK v5.0
# ===============================================================================
# Description: Restaure les donn√©es √† partir des sauvegardes avec variables d'environnement
# Version: 5.0.0
# Date: 01/06/2025
# Author: LIONS DevOps Team
# ===============================================================================

- name: "Restauration des donn√©es LIONS {{ lions_environment | default(lookup('env', 'LIONS_ENVIRONMENT')) | upper }}"
  hosts: all
  become: true
  gather_facts: true
  
  vars:
    # =========================================================================
    # CONFIGURATION DE BASE DEPUIS VARIABLES D'ENVIRONNEMENT
    # =========================================================================
    lions_environment: "{{ lookup('env', 'LIONS_ENVIRONMENT') | default('development') }}"
    lions_project_name: "{{ lookup('env', 'LIONS_PROJECT_NAME') | default('lions-infrastructure') }}"
    lions_version: "{{ lookup('env', 'LIONS_VERSION') | default('5.0.0') }}"
    lions_deployment_id: "{{ lookup('env', 'LIONS_DEPLOYMENT_ID') | default(ansible_date_time.epoch) }}"
    
    # =========================================================================
    # CONFIGURATION DE RESTAURATION
    # =========================================================================
    restore_timestamp: "{{ ansible_date_time.date }}_{{ ansible_date_time.hour }}{{ ansible_date_time.minute }}{{ ansible_date_time.second }}"
    backup_root_dir: "{{ lookup('env', 'LIONS_BACKUP_ROOT_DIR') | default('/var/backups/lions') }}"
    restore_log_path: "{{ lookup('env', 'LIONS_LOG_PATH') | default('/var/log/lions') }}/restores"
    restore_log_file: "{{ restore_log_path }}/restore-{{ lions_environment }}-{{ restore_timestamp }}.log"
    restore_temp_dir: "/tmp/lions-restore-{{ lions_deployment_id }}"
    
    # Fichier de sauvegarde √† restaurer (obligatoire)
    backup_file: "{{ backup_file | default(lookup('env', 'LIONS_RESTORE_BACKUP_FILE')) }}"
    backup_encryption_enabled: "{{ lookup('env', 'LIONS_BACKUP_ENCRYPTION_ENABLED') | default('true') | bool }}"
    backup_encryption_key: "{{ lookup('vault', 'secret/lions/' + lions_environment + '/backup:encryption_key') | default(lookup('env', 'LIONS_BACKUP_ENCRYPTION_KEY')) }}"
    
    # =========================================================================
    # CONFIGURATION KUBERNETES
    # =========================================================================
    kube_config_path: "{{ lookup('env', 'LIONS_KUBE_CONFIG_PATH') | default(ansible_env.HOME + '/.kube/config') }}"
    kubectl_timeout: "{{ lookup('env', 'LIONS_KUBECTL_TIMEOUT') | default('5m') }}"
    namespace_prefix: "{{ lookup('env', 'LIONS_NAMESPACE_PREFIX') | default('lions-' + lions_environment) }}"
    
    # =========================================================================
    # CONFIGURATION BASE DE DONN√âES
    # =========================================================================
    postgres_enabled: "{{ lookup('env', 'LIONS_POSTGRES_ENABLED') | default('true') | bool }}"
    postgres_username: "{{ lookup('vault', 'secret/lions/' + lions_environment + '/postgres:username') | default(lookup('env', 'LIONS_POSTGRES_USERNAME')) | default('lions_user') }}"
    postgres_admin_password: "{{ lookup('vault', 'secret/lions/' + lions_environment + '/postgres:admin_password') | default(lookup('env', 'LIONS_POSTGRES_ADMIN_PASSWORD')) }}"
    postgres_backup_format: "{{ lookup('env', 'LIONS_POSTGRES_BACKUP_FORMAT') | default('custom') }}"
    
    # =========================================================================
    # CONFIGURATION VAULT
    # =========================================================================
    vault_enabled: "{{ lookup('env', 'LIONS_VAULT_ENABLED') | default('true') | bool }}"
    vault_addr: "{{ lookup('env', 'LIONS_VAULT_ADDR') }}"
    vault_namespace: "{{ lookup('env', 'LIONS_VAULT_NAMESPACE') | default('vault-system') }}"
    
    # =========================================================================
    # MODES DE RESTAURATION
    # =========================================================================
    restore_mode: "{{ restore_mode | default(lookup('env', 'LIONS_RESTORE_MODE')) | default('selective') }}"  # selective, full, data-only
    restore_force: "{{ restore_force | default(lookup('env', 'LIONS_RESTORE_FORCE')) | default('false') | bool }}"
    restore_verify: "{{ lookup('env', 'LIONS_RESTORE_VERIFY') | default('true') | bool }}"
    restore_dry_run: "{{ restore_dry_run | default(lookup('env', 'LIONS_RESTORE_DRY_RUN')) | default('false') | bool }}"
    
    # =========================================================================
    # COMPOSANTS DE RESTAURATION CONFIGURABLES
    # =========================================================================
    restore_components:
      - name: "Bases de donn√©es PostgreSQL"
        enabled: "{{ postgres_enabled and (restore_mode in ['full', 'data-only']) }}"
        priority: 1
        critical: true
      - name: "Volumes persistants Kubernetes"
        enabled: "{{ lookup('env', 'LIONS_RESTORE_PVC_ENABLED') | default('true') | bool and (restore_mode in ['full', 'data-only']) }}"
        priority: 2
        critical: true
      - name: "Configurations Kubernetes"
        enabled: "{{ lookup('env', 'LIONS_RESTORE_K8S_CONFIG_ENABLED') | default('false') | bool and restore_mode == 'full' }}"
        priority: 3
        critical: false
      - name: "Certificats et secrets"
        enabled: "{{ lookup('env', 'LIONS_RESTORE_CERTS_ENABLED') | default('false') | bool and restore_mode == 'full' }}"
        priority: 4
        critical: false
      - name: "HashiCorp Vault"
        enabled: "{{ vault_enabled and lookup('env', 'LIONS_RESTORE_VAULT_ENABLED') | default('false') | bool and restore_mode == 'full' }}"
        priority: 5
        critical: false

  environment:
    KUBECONFIG: "{{ kube_config_path }}"
    LIONS_ENVIRONMENT: "{{ lions_environment }}"
    LIONS_RESTORE_ID: "{{ lions_deployment_id }}"

  pre_tasks:
    # =========================================================================
    # VALIDATION PR√â-RESTAURATION
    # =========================================================================
    - name: "Validation de la configuration de restauration"
      assert:
        that:
          - backup_file is defined and backup_file != ""
          - lions_environment is defined
          - restore_log_path is defined
        fail_msg: "Configuration de restauration invalide - Fichier de sauvegarde requis"
        success_msg: "Configuration de restauration valid√©e pour l'environnement {{ lions_environment }}"

    - name: "V√©rification de l'existence du fichier de sauvegarde"
      stat:
        path: "{{ backup_file }}"
      register: backup_file_stat
      failed_when: not backup_file_stat.stat.exists

    - name: "Affichage des informations de restauration"
      debug:
        msg:
          - "==============================================================================="
          - "LIONS INFRASTRUCTURE - RESTAURATION DE DONN√âES"
          - "==============================================================================="
          - "Environnement: {{ lions_environment }}"
          - "Version: {{ lions_version }}"
          - "Fichier de sauvegarde: {{ backup_file }}"
          - "Taille: {{ (backup_file_stat.stat.size / 1048576) | round(2) }} MB"
          - "Mode de restauration: {{ restore_mode }}"
          - "Dry run: {{ restore_dry_run }}"
          - "Force: {{ restore_force }}"
          - "V√©rification: {{ restore_verify }}"
          - "ID de restauration: {{ lions_deployment_id }}"
          - "Composants activ√©s: {{ restore_components | selectattr('enabled') | list | length }}/{{ restore_components | list | length }}"
          - "==============================================================================="

    - name: "Confirmation de restauration (si pas en mode force)"
      pause:
        prompt: |
          ‚ö†Ô∏è  ATTENTION: OP√âRATION DE RESTAURATION CRITIQUE ‚ö†Ô∏è
          
          Vous √™tes sur le point de restaurer des donn√©es dans l'environnement {{ lions_environment }}.
          Cette op√©ration peut √âCRASER les donn√©es existantes et causer des interruptions de service.
          
          Fichier de sauvegarde: {{ backup_file }}
          Mode: {{ restore_mode }}
          
          √ätes-vous absolument certain de vouloir continuer? (yes/no)
      register: restore_confirmation
      when: not restore_force | bool

    - name: "Validation de la confirmation"
      fail:
        msg: "Restauration annul√©e par l'utilisateur"
      when: 
        - not restore_force | bool
        - restore_confirmation.user_input | lower != 'yes'

  tasks:
    # =========================================================================
    # INITIALISATION
    # =========================================================================
    - name: "Cr√©ation des r√©pertoires de restauration"
      file:
        path: "{{ item }}"
        state: directory
        mode: '0750'
        owner: root
        group: root
      loop:
        - "{{ restore_log_path }}"
        - "{{ restore_temp_dir }}"
        - "{{ restore_temp_dir }}/databases"
        - "{{ restore_temp_dir }}/kubernetes"
        - "{{ restore_temp_dir }}/certificates"
        - "{{ restore_temp_dir }}/vault"
      tags: ['restore', 'init']

    - name: "Initialisation du log de restauration"
      copy:
        content: |
          ===============================================================================
          LIONS INFRASTRUCTURE - LOG DE RESTAURATION
          ===============================================================================
          Environnement: {{ lions_environment }}
          Version: {{ lions_version }}
          ID Restauration: {{ lions_deployment_id }}
          Date de d√©but: {{ ansible_date_time.iso8601 }}
          Fichier source: {{ backup_file }}
          Mode: {{ restore_mode }}
          Dry Run: {{ restore_dry_run }}
          Force: {{ restore_force }}
          ===============================================================================
        dest: "{{ restore_log_file }}"
        mode: '0644'
      tags: ['restore', 'init']

    # =========================================================================
    # D√âCHIFFREMENT ET EXTRACTION
    # =========================================================================
    - name: "D√©chiffrement de la sauvegarde (si chiffr√©e)"
      shell: |
        if [[ "{{ backup_file }}" == *.gpg ]]; then
          gpg --decrypt --batch --passphrase "{{ backup_encryption_key }}" \
            --output "{{ restore_temp_dir }}/backup.tar.gz" \
            "{{ backup_file }}"
          echo "{{ restore_temp_dir }}/backup.tar.gz"
        else
          echo "{{ backup_file }}"
        fi
      register: decrypted_backup
      when: 
        - backup_encryption_enabled | bool
        - backup_encryption_key is defined and backup_encryption_key != ""
      tags: ['restore', 'decrypt']

    - name: "D√©termination du fichier √† extraire"
      set_fact:
        source_backup_file: "{{ decrypted_backup.stdout | default(backup_file) }}"
      tags: ['restore', 'extract']

    - name: "Extraction de l'archive de sauvegarde"
      unarchive:
        src: "{{ source_backup_file }}"
        dest: "{{ restore_temp_dir }}"
        remote_src: yes
        creates: "{{ restore_temp_dir }}/extracted"
      register: extract_result
      tags: ['restore', 'extract']

    - name: "Marquage de l'extraction"
      file:
        path: "{{ restore_temp_dir }}/extracted"
        state: touch
      when: extract_result is succeeded
      tags: ['restore', 'extract']

    - name: "Recherche du r√©pertoire de sauvegarde extrait"
      find:
        paths: "{{ restore_temp_dir }}"
        file_type: directory
        recurse: no
        excludes: "databases,kubernetes,certificates,vault"
      register: extracted_dirs
      tags: ['restore', 'extract']

    - name: "D√©termination du chemin de la sauvegarde"
      set_fact:
        backup_path: "{{ extracted_dirs.files[0].path if extracted_dirs.matched > 0 else restore_temp_dir }}"
      tags: ['restore', 'extract']

    # =========================================================================
    # RESTAURATION DES BASES DE DONN√âES POSTGRESQL
    # =========================================================================
    - name: "üíæ RESTAURATION 1 - Bases de donn√©es PostgreSQL"
      block:
        - name: "Recherche des sauvegardes PostgreSQL"
          find:
            paths: "{{ backup_path }}/databases"
            patterns: "*.dump,*.sql,*.sql.gz"
            recurse: no
          register: postgres_dumps

        - name: "Parsing des informations de restauration PostgreSQL"
          set_fact:
            postgres_restore_list: >-
              {{
                postgres_dumps.files | map('regex_replace', '^.*/([^-]+)-([^-]+)-.*\\.(dump|sql)(\\.gz)?$', '{"namespace": "\\1", "database": "\\2", "file": "\\g<0>", "format": "\\3"}') |
                map('from_json') | list
              }}

        - name: "Restauration de chaque base PostgreSQL"
          include_tasks: "{{ playbook_dir }}/../tasks/restore-postgres-database.yml"
          vars:
            db_namespace: "{{ item.namespace }}"
            db_name: "{{ item.database }}"
            db_backup_file: "{{ item.file }}"
            db_format: "{{ item.format }}"
            db_admin_user: "postgres"
            db_admin_password: "{{ postgres_admin_password }}"
            dry_run: "{{ restore_dry_run }}"
          loop: "{{ postgres_restore_list }}"
          when: 
            - postgres_restore_list | length > 0
            - not restore_dry_run | bool or item.database != ""

        - name: "Enregistrement de la restauration PostgreSQL"
          lineinfile:
            path: "{{ restore_log_file }}"
            line: "‚úÖ Restauration PostgreSQL termin√©e - {{ ansible_date_time.iso8601 }} - Bases restaur√©es: {{ postgres_restore_list | length }}"

      when: restore_components | selectattr('name', 'equalto', 'Bases de donn√©es PostgreSQL') | selectattr('enabled') | list | length > 0
      tags: ['restore', 'postgres']

    # =========================================================================
    # RESTAURATION DES VOLUMES PERSISTANTS KUBERNETES
    # =========================================================================
    - name: "üìÅ RESTAURATION 2 - Volumes persistants Kubernetes"
      block:
        - name: "Recherche des sauvegardes de volumes"
          find:
            paths: "{{ backup_path }}/kubernetes"
            patterns: "*-pvc-*.tar.gz,*-volume-*.tar.gz"
            recurse: no
          register: volume_backups

        - name: "Parsing des informations de volumes"
          set_fact:
            volume_restore_list: >-
              {{
                volume_backups.files | map('regex_replace', '^.*/([^-]+)-([^-]+)-.*\\.tar\\.gz$', '{"namespace": "\\1", "pvc": "\\2", "file": "\\g<0>"}') |
                map('from_json') | list
              }}

        - name: "Restauration de chaque volume via snapshots"
          include_tasks: "{{ playbook_dir }}/../tasks/restore-pvc-volume.yml"
          vars:
            pvc_namespace: "{{ item.namespace }}"
            pvc_name: "{{ item.pvc }}"
            pvc_backup_file: "{{ item.file }}"
            snapshot_class: "{{ lookup('env', 'LIONS_SNAPSHOT_CLASS') | default('csi-snapshot') }}"
            dry_run: "{{ restore_dry_run }}"
            force_restore: "{{ restore_force }}"
          loop: "{{ volume_restore_list }}"
          when: 
            - volume_restore_list | length > 0
            - not restore_dry_run | bool or item.pvc != ""

        - name: "Enregistrement de la restauration des volumes"
          lineinfile:
            path: "{{ restore_log_file }}"
            line: "‚úÖ Restauration volumes termin√©e - {{ ansible_date_time.iso8601 }} - Volumes restaur√©s: {{ volume_restore_list | length }}"

      when: restore_components | selectattr('name', 'equalto', 'Volumes persistants Kubernetes') | selectattr('enabled') | list | length > 0
      tags: ['restore', 'volumes']

    # =========================================================================
    # RESTAURATION DES CONFIGURATIONS KUBERNETES
    # =========================================================================
    - name: "‚öôÔ∏è RESTAURATION 3 - Configurations Kubernetes"
      block:
        - name: "Recherche des configurations Kubernetes"
          find:
            paths: "{{ backup_path }}/kubernetes"
            patterns: "*.yaml,*.yml"
            excludes: "*secret*,*certificate*"
            recurse: no
          register: k8s_configs

        - name: "Validation des configurations avant restauration"
          shell: "kubectl apply --dry-run=client -f {{ item.path }}"
          loop: "{{ k8s_configs.files }}"
          register: config_validation
          ignore_errors: yes
          when: 
            - k8s_configs.matched > 0
            - restore_verify | bool

        - name: "Demande de confirmation pour configurations critiques"
          pause:
            prompt: |
              ‚ö†Ô∏è  ATTENTION: RESTAURATION DE CONFIGURATIONS KUBERNETES ‚ö†Ô∏è
              
              {{ k8s_configs.matched }} configurations trouv√©es.
              La restauration peut cr√©er des conflits avec les ressources existantes.
              
              Continuer? (yes/no)
          register: config_confirmation
          when: 
            - k8s_configs.matched > 0
            - not restore_force | bool
            - not restore_dry_run | bool

        - name: "Restauration des configurations Kubernetes"
          shell: "kubectl apply -f {{ item.path }}"
          loop: "{{ k8s_configs.files }}"
          register: k8s_restore_results
          when: 
            - k8s_configs.matched > 0
            - not restore_dry_run | bool
            - restore_force | bool or (config_confirmation.user_input | default('no') | lower == 'yes')
          ignore_errors: yes

        - name: "Enregistrement de la restauration des configurations"
          lineinfile:
            path: "{{ restore_log_file }}"
            line: "‚úÖ Restauration configurations K8s termin√©e - {{ ansible_date_time.iso8601 }} - Fichiers: {{ k8s_configs.matched }}"

      when: restore_components | selectattr('name', 'equalto', 'Configurations Kubernetes') | selectattr('enabled') | list | length > 0
      tags: ['restore', 'k8s-config']

    # =========================================================================
    # RESTAURATION DES CERTIFICATS ET SECRETS
    # =========================================================================
    - name: "üîê RESTAURATION 4 - Certificats et secrets"
      block:
        - name: "Recherche des certificats et secrets"
          find:
            paths: "{{ backup_path }}/certificates"
            patterns: "certificates-*.yaml,secrets-*.json"
            recurse: no
          register: cert_files

        - name: "Demande de confirmation pour certificats"
          pause:
            prompt: |
              üîí ATTENTION: RESTAURATION DE CERTIFICATS ET SECRETS üîí
              
              {{ cert_files.matched }} fichiers de certificats/secrets trouv√©s.
              La restauration de certificats peut compromettre la s√©curit√©.
              
              √äTES-VOUS ABSOLUMENT CERTAIN? (YES en majuscules pour confirmer)
          register: cert_confirmation
          when: 
            - cert_files.matched > 0
            - not restore_force | bool
            - not restore_dry_run | bool

        - name: "Restauration s√©lective des certificats"
          shell: "kubectl apply -f {{ item.path }}"
          loop: "{{ cert_files.files }}"
          register: cert_restore_results
          when: 
            - cert_files.matched > 0
            - not restore_dry_run | bool
            - restore_force | bool or (cert_confirmation.user_input | default('no') == 'YES')
            - '"certificate" in item.path'
          ignore_errors: yes

        - name: "Enregistrement de la restauration des certificats"
          lineinfile:
            path: "{{ restore_log_file }}"
            line: "‚úÖ Restauration certificats termin√©e - {{ ansible_date_time.iso8601 }} - Restaur√©s: {{ cert_restore_results.results | default([]) | selectattr('rc', 'equalto', 0) | list | length }}"

      when: restore_components | selectattr('name', 'equalto', 'Certificats et secrets') | selectattr('enabled') | list | length > 0
      tags: ['restore', 'certs']

    # =========================================================================
    # RESTAURATION HASHICORP VAULT
    # =========================================================================
    - name: "üîë RESTAURATION 5 - HashiCorp Vault"
      block:
        - name: "Recherche des sauvegardes Vault"
          find:
            paths: "{{ backup_path }}/vault"
            patterns: "vault-*.json,vault-*.snapshot"
            recurse: no
          register: vault_backups

        - name: "Restauration Vault via API"
          include_tasks: "{{ playbook_dir }}/../tasks/restore-vault.yml"
          vars:
            vault_backup_file: "{{ item.path }}"
            vault_target_addr: "{{ vault_addr }}"
            vault_target_namespace: "{{ vault_namespace }}"
            dry_run: "{{ restore_dry_run }}"
          loop: "{{ vault_backups.files }}"
          when: 
            - vault_backups.matched > 0
            - vault_addr is defined and vault_addr != ""

        - name: "Enregistrement de la restauration Vault"
          lineinfile:
            path: "{{ restore_log_file }}"
            line: "‚úÖ Restauration Vault termin√©e - {{ ansible_date_time.iso8601 }} - Fichiers: {{ vault_backups.matched }}"

      when: restore_components | selectattr('name', 'equalto', 'HashiCorp Vault') | selectattr('enabled') | list | length > 0
      tags: ['restore', 'vault']

    # =========================================================================
    # V√âRIFICATION POST-RESTAURATION
    # =========================================================================
    - name: "üîç V√©rification post-restauration"
      block:
        - name: "V√©rification de l'√©tat du cluster"
          shell: "kubectl get nodes --no-headers | wc -l"
          register: cluster_nodes
          environment:
            KUBECONFIG: "{{ kube_config_path }}"

        - name: "V√©rification des pods critiques"
          shell: |
            kubectl get pods --all-namespaces -l app.kubernetes.io/part-of=lions \
            --field-selector=status.phase=Running --no-headers | wc -l
          register: running_pods
          environment:
            KUBECONFIG: "{{ kube_config_path }}"

        - name: "Test de connectivit√© des services"
          uri:
            url: "https://{{ item }}/health"
            method: GET
            status_code: [200, 404, 503]
            timeout: 10
          loop:
            - "{{ lookup('env', 'LIONS_KEYCLOAK_DOMAIN') | default('keycloak.' + lions_env_domain) }}"
            - "{{ lookup('env', 'LIONS_GITEA_DOMAIN') | default('gitea.' + lions_env_domain) }}"
          register: service_health
          ignore_errors: yes
          when: restore_verify | bool

        - name: "Rapport de v√©rification"
          debug:
            msg:
              - "==============================================================================="
              - "RAPPORT DE V√âRIFICATION POST-RESTAURATION"
              - "==============================================================================="
              - "N≈ìuds du cluster: {{ cluster_nodes.stdout }}"
              - "Pods LIONS en cours d'ex√©cution: {{ running_pods.stdout }}"
              - "Services test√©s: {{ service_health.results | default([]) | length }}"
              - "Services accessibles: {{ service_health.results | default([]) | selectattr('status', 'defined') | selectattr('status', 'equalto', 200) | list | length }}"
              - "==============================================================================="

      when: restore_verify | bool
      tags: ['restore', 'verify']

    # =========================================================================
    # FINALISATION ET NETTOYAGE
    # =========================================================================
    - name: "G√©n√©ration du rapport de restauration"
      copy:
        content: |
          ===============================================================================
          LIONS INFRASTRUCTURE - RAPPORT DE RESTAURATION
          ===============================================================================
          Date: {{ ansible_date_time.iso8601 }}
          Environnement: {{ lions_environment }}
          ID Restauration: {{ lions_deployment_id }}
          Fichier source: {{ backup_file }}
          Taille source: {{ (backup_file_stat.stat.size / 1048576) | round(2) }} MB
          
          Configuration:
            Mode: {{ restore_mode }}
            Dry Run: {{ restore_dry_run }}
            Force: {{ restore_force }}
            V√©rification: {{ restore_verify }}
          
          Composants restaur√©s:
            - PostgreSQL: {{ restore_components | selectattr('name', 'equalto', 'Bases de donn√©es PostgreSQL') | selectattr('enabled') | list | length > 0 }}
            - Volumes K8s: {{ restore_components | selectattr('name', 'equalto', 'Volumes persistants Kubernetes') | selectattr('enabled') | list | length > 0 }}
            - Configurations K8s: {{ restore_components | selectattr('name', 'equalto', 'Configurations Kubernetes') | selectattr('enabled') | list | length > 0 }}
            - Certificats: {{ restore_components | selectattr('name', 'equalto', 'Certificats et secrets') | selectattr('enabled') | list | length > 0 }}
            - Vault: {{ restore_components | selectattr('name', 'equalto', 'HashiCorp Vault') | selectattr('enabled') | list | length > 0 }}
          
          R√©sultats de v√©rification:
            - N≈ìuds cluster: {{ cluster_nodes.stdout | default('N/A') }}
            - Pods LIONS actifs: {{ running_pods.stdout | default('N/A') }}
            - Services accessibles: {{ service_health.results | default([]) | selectattr('status', 'equalto', 200) | list | length }}/{{ service_health.results | default([]) | length }}
          
          ===============================================================================
        dest: "{{ restore_log_path }}/restore-report-{{ lions_deployment_id }}.txt"
        mode: '0644'
      tags: ['restore', 'report']

    - name: "Nettoyage des fichiers temporaires"
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - "{{ restore_temp_dir }}"
        - "{{ restore_temp_dir }}/backup.tar.gz"
      ignore_errors: yes
      tags: ['restore', 'cleanup']

    - name: "Finalisation du log de restauration"
      lineinfile:
        path: "{{ restore_log_file }}"
        line: |
          ===============================================================================
          ‚úÖ RESTAURATION TERMIN√âE AVEC SUCC√àS
          Date de fin: {{ ansible_date_time.iso8601 }}
          Dur√©e: {{ ((ansible_date_time.epoch | int) - (restore_timestamp | regex_replace('.*_([0-9]{6}).*', '\\1') | int)) // 60 }} minutes
          Rapport: {{ restore_log_path }}/restore-report-{{ lions_deployment_id }}.txt
          ===============================================================================
      tags: ['restore', 'finalize']

  post_tasks:
    # =========================================================================
    # NOTIFICATION DE FIN DE RESTAURATION
    # =========================================================================
    - name: "Notification de succ√®s de restauration"
      uri:
        url: "{{ lookup('env', 'LIONS_NOTIFICATION_WEBHOOK_URL') }}"
        method: POST
        body_format: json
        body:
          text: "‚úÖ Restauration LIONS {{ lions_environment }} termin√©e avec succ√®s"
          environment: "{{ lions_environment }}"
          backup_file: "{{ backup_file | basename }}"
          restore_mode: "{{ restore_mode }}"
          restore_id: "{{ lions_deployment_id }}"
          dry_run: "{{ restore_dry_run }}"
          components_restored: "{{ restore_components | selectattr('enabled') | list | length }}"
          cluster_nodes: "{{ cluster_nodes.stdout | default('N/A') }}"
          running_pods: "{{ running_pods.stdout | default('N/A') }}"
      when: 
        - lookup('env', 'LIONS_NOTIFICATION_WEBHOOK_URL') != ""
        - not restore_dry_run | bool
      ignore_errors: yes

  handlers:
    - name: "Notification d'√©chec de restauration"
      uri:
        url: "{{ lookup('env', 'LIONS_NOTIFICATION_WEBHOOK_URL') }}"
        method: POST
        body_format: json
        body:
          text: "‚ùå √âchec de restauration LIONS {{ lions_environment }}"
          environment: "{{ lions_environment }}"
          backup_file: "{{ backup_file | basename }}"
          restore_mode: "{{ restore_mode }}"
          restore_id: "{{ lions_deployment_id }}"
          error: "{{ ansible_failed_result.msg | default('Unknown error') }}"
      when: lookup('env', 'LIONS_NOTIFICATION_WEBHOOK_URL') != ""
      listen: "restore failed"